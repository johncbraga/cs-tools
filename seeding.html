<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Seeding • Gerador de Confrontos</title>

  <style>
  /* ====== CSS (tudo em um arquivo) ====== */
  :root{
    --bg:#0b1220;
    --card:#111a2e;
    --card2:#0f1730;
    --text:#e7ecff;
    --muted:#a9b3d6;
    --accent:#6ea8ff;
    --accent2:#7cf2c2;
    --danger:#ff6e6e;
    --border:rgba(231,236,255,.12);
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;
    background:radial-gradient(1000px 700px at 20% -10%, rgba(110,168,255,.20), transparent 60%),
               radial-gradient(900px 650px at 90% 0%, rgba(124,242,194,.14), transparent 55%),
               var(--bg);
    color:var(--text);
  }
  .topbar{
    position:sticky; top:0;
    display:flex; align-items:flex-start; justify-content:space-between;
    gap:16px;
    padding:18px 22px;
    border-bottom:1px solid var(--border);
    backdrop-filter: blur(8px);
    background:rgba(11,18,32,.72);
    z-index:10;
  }
  .title h1{margin:0; font-size:20px; letter-spacing:.2px}
  .subtitle{margin:4px 0 0; color:var(--muted); font-size:13px}
  .back-btn{
    margin-left:auto;
    padding:10px 14px;
    border-radius:10px;
    border:1px solid var(--border);
    background:rgba(17,26,46,.7);
    color:var(--text);
    cursor:pointer;
    box-shadow:var(--shadow);
  }
  .back-btn:hover{border-color:rgba(110,168,255,.55)}
  .container{max-width:1150px; margin:18px auto 60px; padding:0 18px}
  .card{
    background:linear-gradient(180deg, rgba(17,26,46,.92), rgba(15,23,48,.92));
    border:1px solid var(--border);
    box-shadow:var(--shadow);
    border-radius:16px;
    padding:16px 16px 14px;
    margin:14px 0;
  }
  .card.subtle{background:rgba(17,26,46,.55)}
  .state{padding:10px 12px; border-radius:12px; border:1px dashed var(--border); color:var(--muted)}
  .row{display:flex; align-items:center; gap:10px; margin-top:10px}
  .row.wrap{flex-wrap:wrap}
  .field{display:flex; flex-direction:column; gap:6px; min-width:230px}
  .field.grow{flex:1; min-width:280px}
  label{font-size:12px; color:var(--muted)}
  input, select, textarea{
    width:100%;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid var(--border);
    background:rgba(8,13,25,.6);
    color:var(--text);
    outline:none;
  }
  textarea{min-height:86px; resize:vertical; font-family:inherit}
  input:focus, select:focus, textarea:focus{border-color:rgba(110,168,255,.75)}
  .btn{
    padding:10px 12px;
    border-radius:12px;
    border:1px solid var(--border);
    background:rgba(8,13,25,.6);
    color:var(--text);
    cursor:pointer;
  }
  .btn:hover{border-color:rgba(110,168,255,.55)}
  .btn.primary{background:linear-gradient(135deg, rgba(110,168,255,.35), rgba(124,242,194,.18)); border-color:rgba(110,168,255,.55)}
  .btn.secondary{background:rgba(255,255,255,.04)}
  .btn:disabled{opacity:.55; cursor:not-allowed}
  .muted{color:var(--muted); font-size:13px}
  .hint{color:var(--muted); font-size:12px; line-height:1.25}
  .list-wrap{margin-top:12px}
  .list-head{display:flex; justify-content:space-between; align-items:center; padding:8px 10px; border:1px solid var(--border); border-radius:12px 12px 0 0; background:rgba(8,13,25,.45)}
  .team-list{
    max-height:340px;
    overflow:auto;
    border:1px solid var(--border);
    border-top:none;
    border-radius:0 0 12px 12px;
    padding:10px;
    background:rgba(8,13,25,.35);
  }
  .team-item{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px 8px; border-radius:10px}
  .team-item:hover{background:rgba(255,255,255,.04)}
  .team-left{display:flex; align-items:center; gap:10px}
  .badge{font-family:var(--mono); font-size:12px; color:var(--muted)}
  .mono{font-family:var(--mono); font-size:13px; white-space:pre-wrap}
  .grid{display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:12px}
  @media (max-width: 980px){.grid{grid-template-columns:1fr}}
  .matchups{display:flex; flex-direction:column; gap:10px}
  .match{
    border:1px solid var(--border);
    border-radius:14px;
    padding:10px 12px;
    background:rgba(8,13,25,.35);
  }
  .match .hdr{display:flex; justify-content:space-between; align-items:center; gap:12px}
  .match .round{color:var(--muted); font-size:12px}
  .pair{display:grid; grid-template-columns:1fr auto 1fr; gap:10px; align-items:center; margin-top:8px}
  .team{
    padding:8px 10px;
    border:1px solid var(--border);
    border-radius:12px;
    background:rgba(255,255,255,.03);
  }
  .team strong{display:block; font-weight:650}
  .team small{color:var(--muted); font-family:var(--mono)}
  .vs{color:var(--accent); font-weight:700}
  .bye{border-color:rgba(124,242,194,.35)}
  .footer{max-width:1150px; margin:18px auto; padding:0 18px 30px;}
  .explain{color:var(--muted); line-height:1.4}
  kbd{border:1px solid var(--border); border-bottom-color:rgba(255,255,255,.25); padding:2px 6px; border-radius:8px; background:rgba(8,13,25,.55); font-family:var(--mono)}
  </style>
</head>
<body>
  <header class="topbar">
    <div class="title">
      <h1>Gerador de Confrontos (Seeding)</h1>
      <p class="subtitle">Melhores vs piores por pontos — com bracket que evita tops se enfrentarem cedo.</p>
    </div>

    <button id="backBtn" class="back-btn" title="Voltar para index.html (atalho: tecla 0)">
      ⟵ Voltar
    </button>
  </header>

  <main class="container">

    <section class="card">
      <h2>1) Fonte do ranking</h2>
      <p>
        O site tenta ler <code>file/ranking.xlsx</code> e usa apenas as colunas <strong>Team</strong> e <strong>Points</strong>.
      </p>

      <div id="loadState" class="state">Carregando ranking…</div>

      <details class="fallback" id="fallbackBox">
        <summary>Não conseguiu ler o Excel? Cole dados manualmente (Team, Points)</summary>
        <p class="hint">Formato: <code>Nome do time;Pontos</code> (uma linha por time) — separador “;” ou “,”.</p>
        <textarea id="manualInput" placeholder="Ex.:
Team A;105
Team B;90
Team C;60"></textarea>
        <div class="row">
          <button id="useManual" class="btn">Usar dados manuais</button>
          <span id="manualStatus" class="muted"></span>
        </div>
      </details>
    </section>

    <section class="card">
      <h2>2) Escolha os times</h2>

      <div class="row wrap">
        <div class="field">
          <label for="filter">Filtro</label>
          <input id="filter" type="text" placeholder="Digite para filtrar…" autocomplete="off" />
        </div>

        <div class="field">
          <label for="stage">Fase</label>
          <select id="stage">
            <option value="auto" selected>Início (auto / chave completa)</option>
            <option value="32">Top 32</option>
            <option value="16">Oitavas (16)</option>
            <option value="8">Quartas (8)</option>
            <option value="4">Semifinal (4)</option>
            <option value="2">Final (2)</option>
          </select>
          <small class="hint">Se você selecionar uma fase menor que a quantidade marcada, o sistema usa os <strong>melhores</strong> por pontos.</small>
        </div>

        <div class="field">
          <label for="reseed">Modo</label>
          <select id="reseed">
            <option value="bracket" selected>Bracket padrão (1 vs N, evita tops cedo)</option>
            <option value="reseed">Re-seeding por rodada (alto vs baixo a cada rodada)</option>
          </select>
          <small class="hint">Use “Re-seeding por rodada” se você quer sempre (em cada rodada) o melhor restante contra o pior restante.</small>
        </div>
      </div>

      <div class="row wrap">
        <div class="field grow">
          <label for="bulkNames">Colar lista de nomes (opcional)</label>
          <textarea id="bulkNames" placeholder="Cole nomes (um por linha) para marcar automaticamente…"></textarea>
          <div class="row">
            <button id="applyBulk" class="btn">Marcar nomes colados</button>
            <button id="clearSel" class="btn secondary">Limpar seleção</button>
            <span class="muted" id="selCount"></span>
          </div>
        </div>
      </div>

      <div class="list-wrap">
        <div class="list-head">
          <span>Times do ranking</span>
          <span class="muted">Marque os que vão participar</span>
        </div>
        <div id="teamList" class="team-list"></div>
      </div>

    </section>

    <section class="card">
      <h2>3) Confrontos</h2>
      <div class="row wrap">
        <button id="generate" class="btn primary">Gerar confrontos</button>
        <button id="copy" class="btn" disabled>Copiar</button>
        <button id="download" class="btn" disabled>Baixar .txt</button>
        <span id="genInfo" class="muted"></span>
      </div>

      <div class="grid">
        <div>
          <h3>Selecionados (ordenados por pontos)</h3>
          <div id="selectedTable" class="mono"></div>
        </div>
        <div>
          <h3>Chave / Pairings</h3>
          <div id="matchups" class="matchups"></div>
        </div>
      </div>

      <details class="card subtle">
        <summary>Como o seeding funciona?</summary>
        <div class="explain">
          <p>
            <strong>Bracket padrão</strong>: monta as posições da chave de forma que o Seed 1 e o Seed 2 fiquem em lados opostos.
            Assim, se tudo der certo, eles só se encontram no fim (final). O primeiro round sempre é <em>melhor vs pior</em>.
          </p>
          <p>
            <strong>Re-seeding por rodada</strong>: reordena os classificados por pontos/seed e faz novamente
            <em>melhor restante vs pior restante</em>. Neste arquivo, o modo “re-seeding” gera o <strong>round atual</strong> nessa lógica.
          </p>
          <p>
            Se o número de times não for potência de 2, o sistema cria <em>BYEs</em> para completar a chave.
          </p>
        </div>
      </details>
    </section>

  </main>

  <footer class="footer">
    <span class="muted">Atalho: tecla <kbd>0</kbd> (fora de campos) volta para <code>index.html</code>.</span>
  </footer>

  <!-- SheetJS (xlsx) para ler ranking.xlsx no navegador -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <script>
  /* ====== JS (tudo em um arquivo) ======
     Seeding: lê ranking.xlsx (file/ranking.xlsx), filtra times escolhidos e gera confrontos por seeding.
     Regras principais:
     - Usa apenas colunas Team e Points.
     - Ordena por Points desc, depois nome.
     - Bracket padrão: usa ordem de seeds que mantém 1 e 2 em lados opostos, evitando encontro antes do final.
     - Re-seeding por rodada: (opcional) gera pareamentos sempre do melhor restante vs pior restante no round atual.
     - Voltar: botão no topo e tecla 0 (quando não estiver focado em input/textarea/select).
  */

  const RANKING_PATH = 'file/ranking.xlsx';

  const els = {
    loadState: document.getElementById('loadState'),
    fallbackBox: document.getElementById('fallbackBox'),
    manualInput: document.getElementById('manualInput'),
    useManual: document.getElementById('useManual'),
    manualStatus: document.getElementById('manualStatus'),

    filter: document.getElementById('filter'),
    stage: document.getElementById('stage'),
    reseed: document.getElementById('reseed'),

    bulkNames: document.getElementById('bulkNames'),
    applyBulk: document.getElementById('applyBulk'),
    clearSel: document.getElementById('clearSel'),
    selCount: document.getElementById('selCount'),

    teamList: document.getElementById('teamList'),
    generate: document.getElementById('generate'),
    copy: document.getElementById('copy'),
    download: document.getElementById('download'),
    genInfo: document.getElementById('genInfo'),

    selectedTable: document.getElementById('selectedTable'),
    matchups: document.getElementById('matchups'),

    backBtn: document.getElementById('backBtn'),
  };

  let ranking = [];           // [{team, points, seed}]
  let selected = new Set();   // team names
  let lastOutputText = '';

  function normalizeStr(s){
    return (s ?? '').toString().trim();
  }

  function parseNumber(v){
    if (typeof v === 'number') return v;
    if (v === null || v === undefined) return 0;
    const s = v.toString().replace(/\s/g,'').replace(',','.');
    const n = Number(s);
    return Number.isFinite(n) ? n : 0;
  }

  function sortRanking(arr){
    return arr.slice().sort((a,b)=>{
      if (b.points !== a.points) return b.points - a.points;
      return a.team.localeCompare(b.team, 'pt-BR', {sensitivity:'base'});
    });
  }

  function nextPow2(n){
    let p = 1;
    while (p < n) p *= 2;
    return p;
  }

  // Ordem de posições de seeds em um bracket power-of-two.
  // Ex.: n=8 => [1,8,4,5,2,7,3,6]
  function buildSeedOrder(n){
    if (n === 1) return [1];
    if (n === 2) return [1,2];
    let order = [1,2];
    for (let size = 4; size <= n; size *= 2){
      const next = [];
      for (const s of order){
        next.push(s);
        next.push(size + 1 - s);
      }
      order = next;
    }
    return order;
  }

  function isTypingTarget(el){
    if (!el) return false;
    const tag = (el.tagName || '').toLowerCase();
    return tag === 'input' || tag === 'textarea' || tag === 'select' || el.isContentEditable;
  }

  function goBack(){
    window.location.href = 'index.html';
  }

  function escapeHtml(str){
    return (str || '').replace(/[&<>\"']/g, (m)=>({
      '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#039;'
    }[m]));
  }

  // UI render
  function renderTeamList(){
    const f = normalizeStr(els.filter.value).toLowerCase();
    const frag = document.createDocumentFragment();

    let visible = 0;
    for (const row of ranking){
      const name = row.team;
      if (f && !name.toLowerCase().includes(f)) continue;
      visible++;

      const item = document.createElement('div');
      item.className = 'team-item';

      const left = document.createElement('div');
      left.className = 'team-left';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = selected.has(name);
      cb.addEventListener('change', ()=>{
        if (cb.checked) selected.add(name); else selected.delete(name);
        updateSelCount();
      });

      const label = document.createElement('div');
      label.innerHTML = `<strong>${escapeHtml(name)}</strong><div class="badge">Points: ${row.points}</div>`;

      left.appendChild(cb);
      left.appendChild(label);

      const right = document.createElement('div');
      right.className = 'badge';
      right.textContent = `#${row.seed}`;

      item.appendChild(left);
      item.appendChild(right);
      frag.appendChild(item);
    }

    els.teamList.innerHTML = '';
    els.teamList.appendChild(frag);

    if (visible === 0){
      els.teamList.innerHTML = `<div class="muted" style="padding:10px">Nenhum time encontrado para o filtro atual.</div>`;
    }
  }

  function updateSelCount(){
    els.selCount.textContent = `${selected.size} selecionado(s)`;
  }

  function parseManualLines(text){
    const lines = (text || '').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    const out = [];
    for (const line of lines){
      const parts = line.includes(';') ? line.split(';') : line.split(',');
      if (parts.length < 2) continue;
      const team = normalizeStr(parts[0]);
      const points = parseNumber(parts.slice(1).join('.'));
      if (team) out.push({team, points});
    }
    return out;
  }

  function applyBulkNames(){
    const names = (els.bulkNames.value || '').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const setLower = new Set(names.map(n=>n.toLowerCase()));
    let matched = 0;
    for (const row of ranking){
      if (setLower.has(row.team.toLowerCase())){
        if (!selected.has(row.team)){
          selected.add(row.team);
          matched++;
        }
      }
    }
    updateSelCount();
    renderTeamList();
    els.genInfo.textContent = matched ? `Marcados ${matched} nome(s) encontrados no ranking.` : 'Nenhum nome colado bateu com o ranking (verifique ortografia).';
  }

  function clearSelection(){
    selected.clear();
    updateSelCount();
    renderTeamList();
    els.genInfo.textContent = '';
  }

  // --- Geração de confrontos ---
  function getStageSize(selectedCount){
    const v = els.stage.value;
    if (v === 'auto') return nextPow2(selectedCount);
    const n = parseInt(v, 10);
    return Number.isFinite(n) && n > 0 ? n : nextPow2(selectedCount);
  }

  function getSelectedTeamsSorted(){
    const chosen = ranking.filter(r => selected.has(r.team));
    return sortRanking(chosen);
  }

  function generateBracketPairings(teams, bracketSize){
    const order = buildSeedOrder(bracketSize);
    // mapa seed -> team
    const seedToTeam = new Map();
    teams.forEach((t, i)=> seedToTeam.set(i+1, t));

    // posições da chave em ordem
    const slots = order.map(seed => ({ seed, team: seedToTeam.get(seed) || null }));

    // confrontos do round 1 = pares consecutivos
    const matches = [];
    for (let i=0;i<slots.length;i+=2){
      matches.push({
        round: 1,
        a: slots[i],
        b: slots[i+1],
      });
    }
    return {matches};
  }

  function generateReseedRound(teams, bracketSize){
    // Round atual no formato 1 vs N, 2 vs N-1, ...
    const seeded = teams.map((t,i)=>({seed:i+1, team:t}));
    const padded = seeded.concat(Array.from({length: bracketSize - seeded.length}, (_,k)=>({seed: seeded.length + k + 1, team:null})));

    const matches = [];
    for (let i=0;i<bracketSize/2;i++){
      const a = padded[i];
      const b = padded[bracketSize - 1 - i];
      matches.push({
        round: 1,
        a: {seed: a.seed, team: a.team},
        b: {seed: b.seed, team: b.team},
      });
    }
    return {matches};
  }

  function renderSelectedTable(teams, capSize){
    let txt = '';
    teams.forEach((t,i)=>{
      txt += `${String(i+1).padStart(2,'0')}  ${t.team}  —  ${t.points}\n`;
    });
    if (capSize && teams.length < capSize){
      txt += `\n(BYEs: +${capSize - teams.length} para completar ${capSize})\n`;
    }
    els.selectedTable.textContent = txt || '—';
  }

  function renderTeamBox(slot){
    const box = document.createElement('div');
    box.className = 'team' + (slot.team ? '' : ' bye');
    if (slot.team){
      box.innerHTML = `<strong>#${slot.seed} ${escapeHtml(slot.team.team)}</strong><small>${slot.team.points} pts</small>`;
    } else {
      box.innerHTML = `<strong>#${slot.seed} BYE</strong><small>avança automaticamente</small>`;
    }
    return box;
  }

  function renderMatches(matches){
    els.matchups.innerHTML = '';
    if (!matches.length){
      els.matchups.innerHTML = '<div class="muted">Sem confrontos para mostrar.</div>';
      return;
    }

    const frag = document.createDocumentFragment();
    matches.forEach((m, idx)=>{
      const div = document.createElement('div');
      div.className = 'match';

      const hdr = document.createElement('div');
      hdr.className = 'hdr';
      hdr.innerHTML = `<div><strong>Jogo ${idx+1}</strong></div><div class="round">Rodada ${m.round}</div>`;

      const pair = document.createElement('div');
      pair.className = 'pair';

      pair.appendChild(renderTeamBox(m.a));
      const vs = document.createElement('div');
      vs.className = 'vs';
      vs.textContent = 'VS';
      pair.appendChild(vs);
      pair.appendChild(renderTeamBox(m.b));

      div.appendChild(hdr);
      div.appendChild(pair);
      frag.appendChild(div);
    });

    els.matchups.appendChild(frag);
  }

  function buildOutputText(matches, stageSize, mode){
    const lines = [];
    lines.push(`Fase/Chave: ${stageSize} (modo: ${mode === 'bracket' ? 'bracket padrão' : 're-seeding por rodada'})`);
    lines.push('');
    matches.forEach((m, idx)=>{
      const a = m.a.team ? `${m.a.team.team} (${m.a.team.points})` : 'BYE';
      const b = m.b.team ? `${m.b.team.team} (${m.b.team.points})` : 'BYE';
      lines.push(`Jogo ${idx+1}: #${m.a.seed} ${a}  vs  #${m.b.seed} ${b}`);
    });
    return lines.join('\n');
  }

  function copyToClipboard(text){
    return navigator.clipboard.writeText(text);
  }

  function downloadText(filename, text){
    const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 0);
  }

  function generate(){
    const teamsAll = getSelectedTeamsSorted();
    if (teamsAll.length < 2){
      els.genInfo.textContent = 'Selecione pelo menos 2 times.';
      return;
    }

    const stageSize = getStageSize(teamsAll.length);
    const mode = els.reseed.value;

    // Se selecionou mais que a fase, corta para os melhores
    const teams = teamsAll.slice(0, stageSize);

    // Completa chave com BYEs até próxima potência de 2
    const bracketSize = nextPow2(stageSize);

    let matches = [];
    if (mode === 'reseed'){
      matches = generateReseedRound(teams, bracketSize).matches;
    } else {
      matches = generateBracketPairings(teams, bracketSize).matches;
    }

    renderSelectedTable(teams, bracketSize);
    renderMatches(matches);

    lastOutputText = buildOutputText(matches, bracketSize, mode);
    els.copy.disabled = false;
    els.download.disabled = false;

    els.genInfo.textContent = `Gerado para ${teams.length} time(s) → chave ${bracketSize}.`;
  }

  // --- Leitura do Excel ---
  function findColumnKey(obj, wanted){
    const keys = Object.keys(obj);
    const lower = wanted.toLowerCase();
    for (const k of keys){
      if (k.toLowerCase() === lower) return k;
    }
    for (const k of keys){
      if (k.toLowerCase().includes(lower)) return k;
    }
    return null;
  }

  async function loadRankingFromXlsx(){
    if (!window.XLSX) throw new Error('Biblioteca XLSX não carregou.');

    const res = await fetch(RANKING_PATH, {cache:'no-store'});
    if (!res.ok) throw new Error(`Não foi possível buscar ${RANKING_PATH} (HTTP ${res.status}).`);
    const buf = await res.arrayBuffer();

    const wb = XLSX.read(buf, {type:'array'});
    const sheetName = wb.SheetNames[0];
    const ws = wb.Sheets[sheetName];
    const rows = XLSX.utils.sheet_to_json(ws, {defval:''});
    if (!rows.length) throw new Error('Planilha vazia.');

    const teamKey = findColumnKey(rows[0], 'Team');
    const pointsKey = findColumnKey(rows[0], 'Points');
    if (!teamKey || !pointsKey){
      throw new Error('Não encontrei as colunas Team e Points.');
    }

    const data = [];
    for (const r of rows){
      const team = normalizeStr(r[teamKey]);
      if (!team) continue;
      const points = parseNumber(r[pointsKey]);
      data.push({team, points});
    }

    const sorted = sortRanking(data);
    sorted.forEach((t,i)=> t.seed = i+1);
    return sorted;
  }

  function setLoadedState(ok, msg){
    els.loadState.textContent = msg;
    els.loadState.style.borderColor = ok ? 'rgba(124,242,194,.35)' : 'rgba(255,110,110,.45)';
    els.loadState.style.color = ok ? 'var(--muted)' : 'var(--danger)';
  }

  async function init(){
    // Voltar
    els.backBtn.addEventListener('click', goBack);
    document.addEventListener('keydown', (e)=>{
      if (e.key === '0' && !isTypingTarget(document.activeElement)){
        e.preventDefault();
        goBack();
      }
    });

    // UI
    els.filter.addEventListener('input', renderTeamList);
    els.applyBulk.addEventListener('click', applyBulkNames);
    els.clearSel.addEventListener('click', clearSelection);
    els.generate.addEventListener('click', generate);

    els.copy.addEventListener('click', async ()=>{
      try{
        await copyToClipboard(lastOutputText);
        els.genInfo.textContent = 'Confrontos copiados!';
      } catch {
        els.genInfo.textContent = 'Não consegui copiar automaticamente. Selecione e copie manualmente.';
      }
    });

    els.download.addEventListener('click', ()=>{
      downloadText('confrontos.txt', lastOutputText || '');
    });

    // Manual fallback
    els.useManual.addEventListener('click', ()=>{
      const data = parseManualLines(els.manualInput.value);
      if (data.length < 2){
        els.manualStatus.textContent = 'Cole pelo menos 2 linhas válidas.';
        return;
      }
      ranking = sortRanking(data).map((t,i)=>({ ...t, seed:i+1 }));
      setLoadedState(true, `Usando dados manuais (${ranking.length} times).`);
      els.manualStatus.textContent = `OK — ${ranking.length} carregados.`;
      renderTeamList();
    });

    // Carrega Excel
    try{
      ranking = await loadRankingFromXlsx();
      setLoadedState(true, `Ranking carregado: ${ranking.length} times (de ${RANKING_PATH}).`);
      els.fallbackBox.open = false;
    } catch (err){
      console.warn(err);
      setLoadedState(false, `Falha ao ler ${RANKING_PATH}. Abra o painel abaixo e cole manualmente, ou rode um servidor local.`);
      els.fallbackBox.open = true;
    }

    updateSelCount();
    renderTeamList();
  }

  document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>