<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pro Analyses</title>

  <!-- SheetJS (XLSX reader) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg: #0b1020;
      --bg2:#070b16;
      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.10);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --accent: #7c5cff;
      --accent2:#23d5ab;
      --danger:#ff4d6d;
      --ok:#2ee59d;
      --warn:#ffcc66;

      --radius: 16px;
      --shadow: 0 14px 45px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(900px 600px at 15% 10%, rgba(124,92,255,.24), transparent 62%),
        radial-gradient(800px 520px at 85% 25%, rgba(35,213,171,.18), transparent 58%),
        linear-gradient(180deg, var(--bg2) 0%, var(--bg) 45%, var(--bg2) 100%);
      background-attachment: fixed;
    }

    .topbar{
      position: sticky;
      top: 0;
      z-index: 10;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      padding: 18px 22px;
      backdrop-filter: blur(12px);
      background: rgba(11,16,32,.65);
      border-bottom: 1px solid var(--stroke);
    }

    .brand{ display:flex; gap:14px; align-items:center; }
    .logo{
      width:44px; height:44px;
      border-radius:14px;
      display:grid; place-items:center;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 10px 28px rgba(124,92,255,.25);
      font-weight:800;
      letter-spacing:.3px;
      user-select:none;
    }
    .title{ margin:0; font-size: 18px; line-height: 1.1; }
    .subtitle{ margin:3px 0 0; color: var(--muted); font-size: 12.5px; }

    .top-actions{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content:flex-end;
    }

    .container{
      max-width: 1180px;
      margin: 0 auto;
      padding: 18px 18px 36px;
    }

    .panel{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      margin-top: 16px;
      overflow: hidden;
    }

    .panel-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      padding: 16px 16px 10px;
      border-bottom: 1px solid rgba(255,255,255,.06);
    }

    .panel-head h2{
      margin:0;
      font-size: 15px;
      letter-spacing:.2px;
      color: rgba(255,255,255,.88);
    }

    .stats{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap: 12px;
      padding: 14px 16px 18px;
    }
    .stat{
      background: var(--card2);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 14px 14px 12px;
      min-height: 76px;
    }
    .stat-label{ color: var(--muted); font-size: 12px; }
    .stat-value{ font-size: 20px; margin-top: 6px; font-weight: 750; }

    .grid-2{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 12px;
      padding: 14px 16px 18px;
    }
    .grid-1{
      padding: 0 16px 18px;
    }

    .filters{
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:end;
      justify-content:flex-end;
    }

    .field{ display:flex; flex-direction:column; gap:6px; }
    label{ font-size: 11.5px; color: var(--muted); }
    input, select{
      width: 220px;
      padding: 10px 11px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
    }
    input::placeholder{ color: rgba(255,255,255,.40); }
    input:focus, select:focus{
      border-color: rgba(124,92,255,.70);
      box-shadow: 0 0 0 4px rgba(124,92,255,.16);
    }

    .btn{
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      font-weight:650;
      text-decoration:none;
      color: var(--text);
      display:inline-flex;
      align-items:center;
      gap: 8px;
      user-select:none;
      background: rgba(255,255,255,.05);
      white-space: nowrap;
    }
    .btn:hover{ background: rgba(255,255,255,.08); }

    .btn-primary{
      background: linear-gradient(135deg, rgba(124,92,255,.95), rgba(35,213,171,.85));
      border-color: rgba(255,255,255,.0);
    }
    .btn-primary:hover{ filter: brightness(1.06); }

    .table-wrap{ overflow:auto; }
    .table{
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      min-width: 980px;
    }
    thead th{
      text-align:left;
      font-size: 12px;
      color: rgba(255,255,255,.78);
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.15);
      position: sticky;
      top: 0;
      backdrop-filter: blur(8px);
    }
    tbody td{
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      font-size: 13px;
      color: rgba(255,255,255,.90);
      vertical-align: middle;
    }
    tbody tr:hover td{ background: rgba(255,255,255,.03); }

    .badge{
      display:inline-flex;
      align-items:center;
      gap: 6px;
      padding: 5px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      white-space: nowrap;
    }
    .badge.ok{ border-color: rgba(46,229,157,.25); background: rgba(46,229,157,.12); }
    .badge.danger{ border-color: rgba(255,77,109,.25); background: rgba(255,77,109,.12); }
    .badge.neutral{ border-color: rgba(255,255,255,.14); background: rgba(255,255,255,.06); }
    .badge.warn{ border-color: rgba(255,204,102,.25); background: rgba(255,204,102,.12); }

    .pill{
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.82);
      white-space: nowrap;
    }
    .pill-good{ border-color: rgba(46,229,157,.25); background: rgba(46,229,157,.12); }
    .pill-bad{ border-color: rgba(255,77,109,.25); background: rgba(255,77,109,.12); }
    .pill-neutral{ border-color: rgba(255,255,255,.14); background: rgba(255,255,255,.06); }
    .pill-warn{ border-color: rgba(255,204,102,.25); background: rgba(255,204,102,.12); }

    .hint{
      padding: 12px 16px 16px;
      color: var(--muted);
      font-size: 12px;
    }

    kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: rgba(255,255,255,.85);
    }

    .footer{
      color: var(--muted);
      font-size: 12px;
      padding: 12px 6px 0;
      text-align:right;
    }

    .errorBox{
      margin: 10px 16px 16px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,77,109,.25);
      background: rgba(255,77,109,.10);
      color: rgba(255,255,255,.88);
      line-height: 1.35;
      display:none;
    }

    .chartCard{
      background: var(--card2);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 14px;
      min-height: 320px;
    }

    .chartTop{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .chartTitle{
      margin:0;
      font-size: 13px;
      color: rgba(255,255,255,.88);
      letter-spacing:.2px;
    }

    .chartMeta{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items:center;
      justify-content:flex-end;
    }

    .metaBox{
      padding: 7px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      font-size: 12px;
      color: rgba(255,255,255,.86);
      white-space: nowrap;
    }

    .canvasWrap{ width: 100%; height: 240px; }
    .canvasWrap.tall{ height: 320px; }
    .canvasWrap canvas{ width: 100% !important; height: 100% !important; }

    .last5{
      display:flex;
      flex-direction:column;
      gap: 10px;
      margin-top: 6px;
    }
    .matchItem{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .matchLeft{
      display:flex;
      flex-direction:column;
      gap: 4px;
      min-width: 0;
    }
    .matchLine1{
      display:flex;
      align-items:center;
      gap: 8px;
      min-width: 0;
      flex-wrap: wrap;
    }
    .matchVs{
      font-weight: 750;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 280px;
    }
    .matchLine2{
      color: rgba(255,255,255,.72);
      font-size: 12px;
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items:center;
    }
    .matchRight{
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content:flex-end;
      text-align:right;
      white-space: nowrap;
    }

    .compareGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      padding: 14px 16px 18px;
    }
    .compareHistory{
      padding: 0 16px 18px;
    }

    @media (max-width: 1020px){
      .stats{ grid-template-columns: repeat(2, minmax(0,1fr)); }
      .grid-2{ grid-template-columns: 1fr; }
      .compareGrid{ grid-template-columns: 1fr; }
      input, select{ width: 190px; }
      .matchVs{ max-width: 220px; }
    }
  </style>
</head>

<body>
  <header class="topbar">
    <div class="brand">
      <div class="logo">PA</div>
      <div>
        <h1 class="title">Pro Analyses</h1>
        <p class="subtitle">Excel-driven match analytics • winner detection + team stats</p>
      </div>
    </div>

    <div class="top-actions">
      <button id="updateBtn" class="btn btn-primary" type="button" title="Force reload the Excel file">Update</button>
      <a class="btn" href="index.html" title="Back to Menu">Back to Menu</a>
    </div>
  </header>

  <main class="container">

    <!-- Dashboard -->
    <section class="panel">
      <div class="panel-head">
        <h2>Dashboard</h2>
        <span id="statusPill" class="pill pill-neutral">Loading…</span>
      </div>

      <div class="stats">
        <div class="stat">
          <div class="stat-label">Total Matches</div>
          <div class="stat-value" id="totalMatches">—</div>
        </div>
        <div class="stat">
          <div class="stat-label">Team 1 Wins</div>
          <div class="stat-value" id="team1Wins">—</div>
        </div>
        <div class="stat">
          <div class="stat-label">Team 2 Wins</div>
          <div class="stat-value" id="team2Wins">—</div>
        </div>
        <div class="stat">
          <div class="stat-label">Most Played Map</div>
          <div class="stat-value" id="topMap">—</div>
        </div>
      </div>

      <div id="errorBox" class="errorBox"></div>
    </section>

    <!-- Team Performance (existing two charts) -->
    <section class="panel">
      <div class="panel-head">
        <h2>Team Performance</h2>

        <div class="filters">
          <div class="field">
            <label for="teamSelect">Team</label>
            <select id="teamSelect">
              <option value="">Select a team</option>
            </select>
          </div>

          <div class="field">
            <label for="teamMapSelect">Map</label>
            <select id="teamMapSelect" disabled>
              <option value="__general__">General (all maps)</option>
            </select>
          </div>
        </div>
      </div>

      <div class="grid-2">
        <div class="chartCard">
          <div class="chartTop">
            <h3 class="chartTitle">Wins vs Losses</h3>
            <div class="chartMeta">
              <div class="metaBox">Total: <b id="totalBox">—</b></div>
              <div class="metaBox">Wins: <b id="winsBox">—</b></div>
              <div class="metaBox">Losses: <b id="lossesBox">—</b></div>
              <div class="metaBox">Win rate: <b id="rateBox">—</b></div>
            </div>
          </div>

          <div class="canvasWrap">
            <canvas id="wlChart" aria-label="Wins and losses chart"></canvas>
          </div>

          <div class="hint">
            Pick a map (or <b>General</b>) to see wins, losses and win rate.
          </div>
        </div>

        <div class="chartCard">
          <div class="chartTop">
            <h3 class="chartTitle">Last 5 Matches</h3>
            <div class="chartMeta">
              <div class="metaBox" id="last5Scope">Scope: General</div>
            </div>
          </div>

          <div id="last5List" class="last5">
            <div class="matchItem">
              <div class="matchLeft">
                <div class="matchLine1">
                  <span class="badge neutral">Select a team</span>
                  <span class="matchVs">to display matches</span>
                </div>
              </div>
            </div>
          </div>

          <div class="hint" style="padding-top:10px;">
            Tip: Press <kbd>0</kbd> to go back (only when not typing in a field).
          </div>
        </div>
      </div>

      <div class="grid-1">
        <div class="chartCard" style="min-height: 380px;">
          <div class="chartTop">
            <h3 class="chartTitle">General Overview (Best/Worst map + Maps played)</h3>
            <div class="chartMeta">
              <div class="metaBox">Best map: <b id="bestMapBox">—</b> <span id="bestMapMeta"></span></div>
              <div class="metaBox">Worst map: <b id="worstMapBox">—</b> <span id="worstMapMeta"></span></div>
            </div>
          </div>

          <div class="canvasWrap tall">
            <canvas id="mapPlayChart" aria-label="Maps played chart"></canvas>
          </div>

          <div class="hint">
            Maps are shown in <b>ascending order</b> by number of matches played for the selected team.
          </div>
        </div>
      </div>
    </section>

    <!-- NEW: Team vs Team Comparison -->
    <section class="panel">
      <div class="panel-head">
        <h2>Team vs Team Comparison</h2>

        <div class="filters">
          <div class="field">
            <label for="compareTeamA">Team A</label>
            <select id="compareTeamA">
              <option value="">Select Team A</option>
            </select>
          </div>

          <div class="field">
            <label for="compareTeamB">Team B</label>
            <select id="compareTeamB">
              <option value="">Select Team B</option>
            </select>
          </div>

          <div class="field">
            <label for="compareMapSelect">Map</label>
            <select id="compareMapSelect" disabled>
              <option value="__general__">General (all maps)</option>
            </select>
          </div>

          <button id="swapBtn" class="btn" type="button" title="Swap teams">Swap</button>
        </div>
      </div>

      <div class="compareGrid">
        <div class="chartCard">
          <div class="chartTop">
            <h3 class="chartTitle">Head-to-Head (Wins)</h3>
            <div class="chartMeta">
              <div class="metaBox">Matches: <b id="h2hMatchesBox">—</b></div>
              <div class="metaBox"><span id="teamANameBox">Team A</span> wins: <b id="h2hAWinsBox">—</b></div>
              <div class="metaBox"><span id="teamBNameBox">Team B</span> wins: <b id="h2hBWinsBox">—</b></div>
            </div>
          </div>

          <div class="canvasWrap">
            <canvas id="h2hBarChart" aria-label="Head-to-head wins chart"></canvas>
          </div>

          <div class="hint" id="h2hHint">
            Select two teams to see their head-to-head record.
          </div>
        </div>

        <div class="chartCard">
          <div class="chartTop">
            <h3 class="chartTitle">Win Probability (Selected map)</h3>
            <div class="chartMeta">
              <div class="metaBox" id="probSourceBox">Source: —</div>
              <div class="metaBox"><span id="probTeamA">Team A</span>: <b id="probABox">—</b></div>
              <div class="metaBox"><span id="probTeamB">Team B</span>: <b id="probBBox">—</b></div>
            </div>
          </div>

          <div class="canvasWrap">
            <canvas id="probDoughnut" aria-label="Win probability chart"></canvas>
          </div>

          <div class="hint" id="probDataHint">
            Probability uses head-to-head data on the chosen map when available; otherwise, it falls back to each team's win rate on that map.
          </div>
        </div>
      </div>

      <div class="compareHistory">
        <div class="chartCard" style="min-height:auto;">
          <div class="chartTop">
            <h3 class="chartTitle">Recent Head-to-Head Matches (for curiosity)</h3>
            <div class="chartMeta">
              <div class="metaBox" id="h2hHistoryScope">Scope: General</div>
            </div>
          </div>

          <div id="h2hHistoryList" class="last5">
            <div class="matchItem">
              <div class="matchLeft">
                <div class="matchLine1">
                  <span class="badge neutral">Select Team A and Team B</span>
                  <span class="matchVs">to display history</span>
                </div>
              </div>
            </div>
          </div>

          <div class="hint">
            “Recent” is based on the latest rows in the Excel file.
          </div>
        </div>
      </div>
    </section>

    <!-- Matches table (kept as before with Opponent filter + Result Win/Lose relative to searched team) -->
    <section class="panel">
      <div class="panel-head">
        <h2>Matches</h2>
        <div class="filters">
          <div class="field">
            <label for="searchInput">Search team</label>
            <input id="searchInput" type="text" placeholder="Type a team name…" autocomplete="off" />
          </div>

          <div class="field">
            <label for="mapSelect">Map</label>
            <select id="mapSelect">
              <option value="">All maps</option>
            </select>
          </div>

          <div class="field">
            <label for="opponentSelect">Opponent</label>
            <select id="opponentSelect" disabled>
              <option value="">All opponents</option>
            </select>
          </div>

          <button id="clearBtn" class="btn btn-primary" type="button">Clear</button>
        </div>
      </div>

      <div class="table-wrap">
        <table class="table" aria-label="Match list">
          <thead>
            <tr>
              <th>#</th>
              <th>Team 1</th>
              <th>Team 2</th>
              <th>Map</th>
              <th>Score</th>
              <th>Result</th>
            </tr>
          </thead>
          <tbody id="matchesTbody">
            <tr>
              <td colspan="6"><span class="badge neutral">Loading</span> Reading Excel…</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="hint">
        Result is shown as <b>Win/Lose</b> from the perspective of the searched team.
      </div>
    </section>

    <footer class="footer">
      <span id="sourceInfo">Source: file/history.xlsx</span>
    </footer>
  </main>

  <script>
    // Source file used: [history.xlsx](https://onedrive.live.com/personal/faa3f9bfbb5dc780/_layouts/15/doc.aspx?resid=4fedb83a-b179-49d6-a8ea-05d25646658b&cid=faa3f9bfbb5dc780&EntityRepresentationId=04785243-ca1a-470c-948d-8b7f73ecddb5) in /file/history.xlsx. [1](https://onedrive.live.com/personal/faa3f9bfbb5dc780/_layouts/15/doc.aspx?resid=4fedb83a-b179-49d6-a8ea-05d25646658b&cid=faa3f9bfbb5dc780)
    // Comparison chart requirement is described in [to-do-games.txt](https://onedrive.live.com/?id=fd403ee0-ec3f-419f-a0e3-88c23ea0cee2&cid=faa3f9bfbb5dc780&web=1&EntityRepresentationId=ef1630bf-291b-4bdd-8538-b6e3c6b4f612). [2](https://onedrive.live.com/?id=fd403ee0-ec3f-419f-a0e3-88c23ea0cee2&cid=faa3f9bfbb5dc780&web=1)

    const EXCEL_PATH = "file/history.xlsx";
    const EXPECTED_HEADERS = ["Team 1", "Team 2", "Map", "Result"];
    const GENERAL_MAP_VALUE = "__general__";

    const els = {
      statusPill: document.getElementById("statusPill"),
      totalMatches: document.getElementById("totalMatches"),
      team1Wins: document.getElementById("team1Wins"),
      team2Wins: document.getElementById("team2Wins"),
      topMap: document.getElementById("topMap"),
      tbody: document.getElementById("matchesTbody"),

      search: document.getElementById("searchInput"),
      mapSelect: document.getElementById("mapSelect"),
      opponentSelect: document.getElementById("opponentSelect"),
      clearBtn: document.getElementById("clearBtn"),

      sourceInfo: document.getElementById("sourceInfo"),
      errorBox: document.getElementById("errorBox"),
      updateBtn: document.getElementById("updateBtn"),

      teamSelect: document.getElementById("teamSelect"),
      teamMapSelect: document.getElementById("teamMapSelect"),

      totalBox: document.getElementById("totalBox"),
      winsBox: document.getElementById("winsBox"),
      lossesBox: document.getElementById("lossesBox"),
      rateBox: document.getElementById("rateBox"),

      last5Scope: document.getElementById("last5Scope"),
      last5List: document.getElementById("last5List"),

      wlCanvas: document.getElementById("wlChart"),
      bestMapBox: document.getElementById("bestMapBox"),
      worstMapBox: document.getElementById("worstMapBox"),
      bestMapMeta: document.getElementById("bestMapMeta"),
      worstMapMeta: document.getElementById("worstMapMeta"),
      mapPlayCanvas: document.getElementById("mapPlayChart"),

      // Comparison UI
      compareTeamA: document.getElementById("compareTeamA"),
      compareTeamB: document.getElementById("compareTeamB"),
      compareMapSelect: document.getElementById("compareMapSelect"),
      swapBtn: document.getElementById("swapBtn"),

      h2hMatchesBox: document.getElementById("h2hMatchesBox"),
      h2hAWinsBox: document.getElementById("h2hAWinsBox"),
      h2hBWinsBox: document.getElementById("h2hBWinsBox"),
      teamANameBox: document.getElementById("teamANameBox"),
      teamBNameBox: document.getElementById("teamBNameBox"),
      h2hHint: document.getElementById("h2hHint"),

      probSourceBox: document.getElementById("probSourceBox"),
      probABox: document.getElementById("probABox"),
      probBBox: document.getElementById("probBBox"),
      probTeamA: document.getElementById("probTeamA"),
      probTeamB: document.getElementById("probTeamB"),
      probDataHint: document.getElementById("probDataHint"),

      h2hHistoryScope: document.getElementById("h2hHistoryScope"),
      h2hHistoryList: document.getElementById("h2hHistoryList"),

      h2hBarCanvas: document.getElementById("h2hBarChart"),
      probCanvas: document.getElementById("probDoughnut")
    };

    let allMatches = [];
    let wlChart = null;
    let mapPlayChart = null;

    // Comparison charts
    let h2hBarChart = null;
    let probDoughnut = null;

    // Cached team lookup for exact match
    let teamLowerToCanonical = new Map();
    let canonicalTeams = [];

    init();

    async function init(){
      els.sourceInfo.textContent = `Source: ${EXCEL_PATH}`;
      setupShortcutBack();
      setupUpdateButton();
      setupTeamControls();
      setupMatchTableControls();
      setupComparisonControls();
      buildCharts();
      await reloadExcel(true);
    }

    function setupUpdateButton(){
      els.updateBtn.addEventListener("click", async () => reloadExcel(true));
    }

    async function reloadExcel(force){
      try{
        setStatus(force ? "Updating… (forcing reload)" : "Loading Excel…", force ? "warn" : "neutral");
        disableUpdate(true);

        allMatches = await loadExcelMatches(EXCEL_PATH, force);

        rebuildTeamLookup(allMatches);
        populateMapOptions(allMatches);
        populateTeamOptions(allMatches);
        populateComparisonTeamOptions(allMatches);

        refreshOpponentOptions();
        applyMatchFilters();
        renderStats(getFilteredMatchesFromControls());

        reconcileTeamSelectionsAfterReload();
        updateTeamSections();

        rebuildCompareMapOptions();
        updateComparison();

        setStatus(`Loaded ${allMatches.length} matches`, "good");
        hideError();
      }catch(err){
        console.error(err);
        setStatus("Failed to load Excel", "bad");
        showError(
          `Could not load <b>${EXCEL_PATH}</b>.<br><span class="small">
           Make sure the file exists in <code>file/</code> and run this page using a local web server (e.g., VS Code Live Server).
           </span>`
        );
        els.tbody.innerHTML = `
          <tr><td colspan="6"><span class="badge danger">Error</span> Could not load <b>${escapeHtml(EXCEL_PATH)}</b>.</td></tr>
        `;
      } finally{
        disableUpdate(false);
      }
    }

    function disableUpdate(disabled){
      els.updateBtn.disabled = disabled;
      els.updateBtn.style.opacity = disabled ? "0.75" : "1";
      els.updateBtn.style.cursor = disabled ? "not-allowed" : "pointer";
    }

    function setStatus(text, state){
      els.statusPill.textContent = text;
      els.statusPill.className =
        "pill " + (state === "good" ? "pill-good" : state === "bad" ? "pill-bad" : state === "warn" ? "pill-warn" : "pill-neutral");
    }

    function showError(html){
      els.errorBox.style.display = "block";
      els.errorBox.innerHTML = html;
    }
    function hideError(){
      els.errorBox.style.display = "none";
      els.errorBox.innerHTML = "";
    }

    function setupShortcutBack(){
      document.addEventListener("keydown", (e) => {
        if (e.key !== "0") return;
        const a = document.activeElement;
        const isTypingContext = a && (a.tagName === "INPUT" || a.tagName === "TEXTAREA" || a.tagName === "SELECT" || a.isContentEditable);
        if (isTypingContext) return;
        e.preventDefault();
        window.history.back();
      });
    }

    /* ----------------------------
       TEAM LOOKUP (exact match)
    -----------------------------*/
    function rebuildTeamLookup(matches){
      const teams = new Set();
      for (const m of matches){ teams.add(m.team1); teams.add(m.team2); }
      canonicalTeams = [...teams].sort((a,b)=>a.localeCompare(b));
      teamLowerToCanonical = new Map();
      for (const t of canonicalTeams) teamLowerToCanonical.set(t.toLowerCase(), t);
    }

    function resolveCanonicalTeam(userText){
      const key = (userText || "").trim().toLowerCase();
      if (!key) return null;
      return teamLowerToCanonical.get(key) || null;
    }

    /* ----------------------------
       MATCH TABLE CONTROLS
    -----------------------------*/
    function setupMatchTableControls(){
      const onAnyChange = () => {
        refreshOpponentOptions();
        applyMatchFilters();
        renderStats(getFilteredMatchesFromControls());
      };

      els.search.addEventListener("input", onAnyChange);
      els.mapSelect.addEventListener("change", onAnyChange);
      els.opponentSelect.addEventListener("change", () => {
        applyMatchFilters();
        renderStats(getFilteredMatchesFromControls());
      });

      els.clearBtn.addEventListener("click", () => {
        els.search.value = "";
        els.mapSelect.value = "";
        els.opponentSelect.value = "";
        els.opponentSelect.disabled = true;
        els.opponentSelect.innerHTML = `<option value="">All opponents</option>`;
        render(allMatches);
        renderStats(allMatches);
      });
    }

    function getFocusTeam(){
      const exactFromSearch = resolveCanonicalTeam(els.search.value);
      if (exactFromSearch) return exactFromSearch;

      const searchEmpty = (els.search.value || "").trim() === "";
      if (searchEmpty && els.teamSelect.value) return els.teamSelect.value;

      return null;
    }

    function refreshOpponentOptions(){
      const focus = getFocusTeam();
      const prev = els.opponentSelect.value;

      if (!focus){
        els.opponentSelect.disabled = true;
        els.opponentSelect.innerHTML = `<option value="">All opponents</option>`;
        return;
      }

      const opponents = new Set();
      for (const m of allMatches){
        if (m.team1 === focus) opponents.add(m.team2);
        else if (m.team2 === focus) opponents.add(m.team1);
      }
      const sortedOpp = [...opponents].sort((a,b)=>a.localeCompare(b));

      els.opponentSelect.disabled = false;
      els.opponentSelect.innerHTML = `<option value="">All opponents</option>`;
      for (const o of sortedOpp){
        const opt = document.createElement("option");
        opt.value = o;
        opt.textContent = o;
        els.opponentSelect.appendChild(opt);
      }

      if (prev && sortedOpp.includes(prev)) els.opponentSelect.value = prev;
      else els.opponentSelect.value = "";
    }

    function getFilteredMatchesFromControls(){
      const q = (els.search.value || "").trim().toLowerCase();
      const map = els.mapSelect.value;
      const focus = getFocusTeam();
      const opponent = els.opponentSelect.value;

      return allMatches.filter(m => {
        const matchesQuery = !q || m.team1.toLowerCase().includes(q) || m.team2.toLowerCase().includes(q);
        if (!matchesQuery) return false;

        const matchesMap = !map || m.map === map;
        if (!matchesMap) return false;

        if (opponent && focus){
          const isPair = (m.team1 === focus && m.team2 === opponent) || (m.team2 === focus && m.team1 === opponent);
          if (!isPair) return false;
        }
        return true;
      });
    }

    function applyMatchFilters(){
      render(getFilteredMatchesFromControls());
    }

    function render(matches){
      const focus = getFocusTeam();
      els.tbody.innerHTML = "";

      if (!matches.length){
        els.tbody.innerHTML = `<tr><td colspan="6"><span class="badge neutral">No results</span> Try clearing filters.</td></tr>`;
        return;
      }

      matches.forEach((m, idx) => {
        const rel = computeRelativeResult(m, focus);
        const resultCell = formatRelativeResultBadge(rel);

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${idx + 1}</td>
          <td>${escapeHtml(m.team1)}</td>
          <td>${escapeHtml(m.team2)}</td>
          <td>${escapeHtml(m.map)}</td>
          <td><span class="badge neutral">${m.score1}x${m.score2}</span></td>
          <td>${resultCell}</td>
        `;
        els.tbody.appendChild(tr);
      });
    }

    function computeRelativeResult(match, focusTeam){
      if (!focusTeam) return { status: "none" };
      const as1 = match.team1 === focusTeam;
      const as2 = match.team2 === focusTeam;
      if (!as1 && !as2) return { status: "none" };
      if (match.winnerSide === "Tie") return { status: "tie" };
      const win = (as1 && match.winnerSide === "Team 1") || (as2 && match.winnerSide === "Team 2");
      return { status: win ? "win" : "lose" };
    }

    function formatRelativeResultBadge(rel){
      if (rel.status === "win") return `<span class="badge ok">Win</span>`;
      if (rel.status === "lose") return `<span class="badge danger">Lose</span>`;
      if (rel.status === "tie") return `<span class="badge neutral">Tie</span>`;
      return `<span class="badge neutral">—</span>`;
    }

    function renderStats(matches){
      els.totalMatches.textContent = matches.length.toString();
      els.team1Wins.textContent = matches.filter(m => m.winnerSide === "Team 1").length.toString();
      els.team2Wins.textContent = matches.filter(m => m.winnerSide === "Team 2").length.toString();

      const mapCounts = new Map();
      for (const m of matches) mapCounts.set(m.map, (mapCounts.get(m.map) || 0) + 1);
      let topMap = "—", topCount = 0;
      for (const [map, count] of mapCounts.entries()){
        if (count > topCount){ topCount = count; topMap = map; }
      }
      els.topMap.textContent = topMap;
    }

    function populateMapOptions(matches){
      while (els.mapSelect.options.length > 1) els.mapSelect.remove(1);
      const maps = [...new Set(matches.map(m => m.map))].sort((a,b)=>a.localeCompare(b));
      for (const mp of maps){
        const opt = document.createElement("option");
        opt.value = mp; opt.textContent = mp;
        els.mapSelect.appendChild(opt);
      }
    }

    /* ----------------------------
       TEAM PERFORMANCE (existing)
    -----------------------------*/
    function setupTeamControls(){
      els.teamSelect.addEventListener("change", () => {
        rebuildTeamMapOptions();
        refreshOpponentOptions();
        updateTeamSections();
      });
      els.teamMapSelect.addEventListener("change", () => updateTeamSections());
    }

    function populateTeamOptions(matches){
      const teams = new Set();
      for (const m of matches){ teams.add(m.team1); teams.add(m.team2); }
      const sorted = [...teams].sort((a,b)=>a.localeCompare(b));

      const prev = els.teamSelect.value;
      els.teamSelect.innerHTML = `<option value="">Select a team</option>`;
      for (const t of sorted){
        const opt = document.createElement("option");
        opt.value = t; opt.textContent = t;
        els.teamSelect.appendChild(opt);
      }
      if (prev && sorted.includes(prev)) els.teamSelect.value = prev;
    }

    function reconcileTeamSelectionsAfterReload(){
      if (els.teamSelect.value) rebuildTeamMapOptions();
      else{
        els.teamMapSelect.disabled = true;
        els.teamMapSelect.innerHTML = `<option value="${GENERAL_MAP_VALUE}">General (all maps)</option>`;
      }
    }

    function rebuildTeamMapOptions(){
      const team = els.teamSelect.value;
      els.teamMapSelect.innerHTML = "";

      const general = document.createElement("option");
      general.value = GENERAL_MAP_VALUE;
      general.textContent = "General (all maps)";
      els.teamMapSelect.appendChild(general);

      if (!team){
        els.teamMapSelect.disabled = true;
        els.teamMapSelect.value = GENERAL_MAP_VALUE;
        return;
      }

      const maps = new Set();
      for (const m of allMatches) if (m.team1 === team || m.team2 === team) maps.add(m.map);
      const sortedMaps = [...maps].sort((a,b)=>a.localeCompare(b));
      for (const mp of sortedMaps){
        const opt = document.createElement("option");
        opt.value = mp; opt.textContent = mp;
        els.teamMapSelect.appendChild(opt);
      }
      els.teamMapSelect.disabled = false;
      if (![...els.teamMapSelect.options].some(o => o.value === els.teamMapSelect.value)){
        els.teamMapSelect.value = GENERAL_MAP_VALUE;
      }
    }

    function computeTeamStats(team, mapValue){
      const mapFilter = (mapValue && mapValue !== GENERAL_MAP_VALUE) ? mapValue : null;
      let wins = 0, losses = 0;

      for (const m of allMatches){
        if (mapFilter && m.map !== mapFilter) continue;

        const as1 = (m.team1 === team);
        const as2 = (m.team2 === team);
        if (!as1 && !as2) continue;

        const win = (as1 && m.winnerSide === "Team 1") || (as2 && m.winnerSide === "Team 2");
        if (win) wins++; else losses++;
      }

      const total = wins + losses;
      const rate = total > 0 ? (wins / total) * 100 : 0;
      return { wins, losses, total, rate };
    }

    function updateTeamSections(){
      updateWLChartAndBoxes();
      updateLast5();
      updateGeneralOverview();
    }

    function updateWLChartAndBoxes(){
      const team = els.teamSelect.value;
      const mapValue = els.teamMapSelect.value || GENERAL_MAP_VALUE;

      if (!team){
        els.totalBox.textContent = "—";
        els.winsBox.textContent = "—";
        els.lossesBox.textContent = "—";
        els.rateBox.textContent = "—";
        wlChart.data.datasets[0].data = [0,0]; wlChart.update();
        return;
      }

      const s = computeTeamStats(team, mapValue);
      els.totalBox.textContent = s.total.toString();
      els.winsBox.textContent = s.wins.toString();
      els.lossesBox.textContent = s.losses.toString();
      els.rateBox.textContent = (s.total > 0 ? `${s.rate.toFixed(1)}%` : "0%");
      wlChart.data.datasets[0].data = [s.wins, s.losses];
      wlChart.update();
    }

    function updateLast5(){
      const team = els.teamSelect.value;
      const mapValue = els.teamMapSelect.value || GENERAL_MAP_VALUE;

      els.last5List.innerHTML = "";
      els.last5Scope.textContent = (mapValue && mapValue !== GENERAL_MAP_VALUE) ? `Scope: ${mapValue}` : "Scope: General";

      if (!team){
        els.last5List.innerHTML = `
          <div class="matchItem">
            <div class="matchLeft">
              <div class="matchLine1">
                <span class="badge neutral">Select a team</span>
                <span class="matchVs">to display matches</span>
              </div>
            </div>
          </div>`;
        return;
      }

      const last = getLastMatches(team, 5, mapValue);
      if (!last.length){
        const label = (mapValue && mapValue !== GENERAL_MAP_VALUE) ? `No matches found on ${escapeHtml(mapValue)}.` : "No matches found for this team.";
        els.last5List.innerHTML = `
          <div class="matchItem">
            <div class="matchLeft">
              <div class="matchLine1">
                <span class="badge warn">No data</span>
                <span class="matchVs">${label}</span>
              </div>
            </div>
          </div>`;
        return;
      }

      for (const item of last){
        const badge = item.isWin ? "ok" : "danger";
        const wlText = item.isWin ? "W" : "L";

        const row = document.createElement("div");
        row.className = "matchItem";
        row.innerHTML = `
          <div class="matchLeft">
            <div class="matchLine1">
              <span class="badge ${badge}">${wlText}</span>
              <span class="matchVs">vs ${escapeHtml(item.opponent)}</span>
            </div>
            <div class="matchLine2">
              <span class="badge neutral">${escapeHtml(item.map)}</span>
              <span class="badge neutral">${item.teamScore}x${item.oppScore}</span>
              <span>${escapeHtml(item.sideLabel)}</span>
            </div>
          </div>
          <div class="matchRight">
            <span class="badge neutral">${escapeHtml(item.rawResult)}</span>
          </div>`;
        els.last5List.appendChild(row);
      }
    }

    function getLastMatches(team, n, mapValue){
      const mapFilter = (mapValue && mapValue !== GENERAL_MAP_VALUE) ? mapValue : null;
      const out = [];

      for (let i = allMatches.length - 1; i >= 0 && out.length < n; i--){
        const m = allMatches[i];
        if (mapFilter && m.map !== mapFilter) continue;

        const as1 = m.team1 === team;
        const as2 = m.team2 === team;
        if (!as1 && !as2) continue;

        const opponent = as1 ? m.team2 : m.team1;
        const teamScore = as1 ? m.score1 : m.score2;
        const oppScore  = as1 ? m.score2 : m.score1;

        const isWin = (as1 && m.winnerSide === "Team 1") || (as2 && m.winnerSide === "Team 2");
        const sideLabel = as1 ? "(Team 1)" : "(Team 2)";

        out.push({
          opponent,
          map: m.map,
          teamScore,
          oppScore,
          isWin,
          sideLabel,
          rawResult: `${m.score1}x${m.score2}`
        });
      }
      return out;
    }

    function updateGeneralOverview(){
      const team = els.teamSelect.value;

      if (!team){
        els.bestMapBox.textContent = "—";
        els.worstMapBox.textContent = "—";
        els.bestMapMeta.textContent = "";
        els.worstMapMeta.textContent = "";
        mapPlayChart.data.labels = [];
        mapPlayChart.data.datasets[0].data = [];
        mapPlayChart.update();
        return;
      }

      const byMap = new Map();
      for (const m of allMatches){
        const as1 = m.team1 === team;
        const as2 = m.team2 === team;
        if (!as1 && !as2) continue;

        if (!byMap.has(m.map)) byMap.set(m.map, { wins:0, losses:0, total:0, rate:0 });
        const s = byMap.get(m.map);
        const win = (as1 && m.winnerSide === "Team 1") || (as2 && m.winnerSide === "Team 2");
        if (win) s.wins++; else s.losses++;
        s.total++;
      }

      for (const s of byMap.values()){
        s.rate = s.total > 0 ? (s.wins / s.total) * 100 : 0;
      }

      const entries = [...byMap.entries()];
      if (!entries.length) return;

      const best = entries.slice().sort((a,b) => (b[1].rate - a[1].rate) || (b[1].total - a[1].total))[0];
      const worst = entries.slice().sort((a,b) => (a[1].rate - b[1].rate) || (b[1].total - a[1].total))[0];

      els.bestMapBox.textContent = best[0];
      els.worstMapBox.textContent = worst[0];
      els.bestMapMeta.textContent = ` (${best[1].rate.toFixed(1)}% • ${best[1].wins}W-${best[1].losses}L • ${best[1].total})`;
      els.worstMapMeta.textContent = ` (${worst[1].rate.toFixed(1)}% • ${worst[1].wins}W-${worst[1].losses}L • ${worst[1].total})`;

      const asc = entries.slice().sort((a,b) => (a[1].total - b[1].total) || a[0].localeCompare(b[0]));
      mapPlayChart.data.labels = asc.map(e => e[0]);
      mapPlayChart.data.datasets[0].data = asc.map(e => e[1].total);

      mapPlayChart.options.plugins.tooltip.callbacks.label = (ctx) => {
        const map = ctx.label;
        const s = byMap.get(map);
        return ` ${s.total} matches • ${s.wins}W-${s.losses}L • ${s.rate.toFixed(1)}% win rate`;
      };
      mapPlayChart.update();
    }

    /* ----------------------------
       NEW: COMPARISON
    -----------------------------*/
    function setupComparisonControls(){
      els.compareTeamA.addEventListener("change", () => {
        rebuildCompareMapOptions();
        updateComparison();
      });
      els.compareTeamB.addEventListener("change", () => {
        rebuildCompareMapOptions();
        updateComparison();
      });
      els.compareMapSelect.addEventListener("change", () => updateComparison());
      els.swapBtn.addEventListener("click", () => {
        const a = els.compareTeamA.value;
        const b = els.compareTeamB.value;
        els.compareTeamA.value = b;
        els.compareTeamB.value = a;
        rebuildCompareMapOptions();
        updateComparison();
      });
    }

    function populateComparisonTeamOptions(matches){
      const teams = new Set();
      for (const m of matches){ teams.add(m.team1); teams.add(m.team2); }
      const sorted = [...teams].sort((a,b)=>a.localeCompare(b));

      const prevA = els.compareTeamA.value;
      const prevB = els.compareTeamB.value;

      els.compareTeamA.innerHTML = `<option value="">Select Team A</option>`;
      els.compareTeamB.innerHTML = `<option value="">Select Team B</option>`;

      for (const t of sorted){
        const o1 = document.createElement("option");
        o1.value = t; o1.textContent = t;
        els.compareTeamA.appendChild(o1);

        const o2 = document.createElement("option");
        o2.value = t; o2.textContent = t;
        els.compareTeamB.appendChild(o2);
      }

      if (prevA && sorted.includes(prevA)) els.compareTeamA.value = prevA;
      if (prevB && sorted.includes(prevB)) els.compareTeamB.value = prevB;
    }

    function rebuildCompareMapOptions(){
      const a = els.compareTeamA.value;
      const b = els.compareTeamB.value;

      els.compareMapSelect.innerHTML = `<option value="${GENERAL_MAP_VALUE}">General (all maps)</option>`;

      if (!a || !b || a === b){
        els.compareMapSelect.disabled = true;
        els.compareMapSelect.value = GENERAL_MAP_VALUE;
        return;
      }

      // Union of maps where either team played (so user can still compare fallback)
      const maps = new Set();
      for (const m of allMatches){
        if (m.team1 === a || m.team2 === a || m.team1 === b || m.team2 === b){
          maps.add(m.map);
        }
      }
      const sortedMaps = [...maps].sort((x,y)=>x.localeCompare(y));
      for (const mp of sortedMaps){
        const opt = document.createElement("option");
        opt.value = mp; opt.textContent = mp;
        els.compareMapSelect.appendChild(opt);
      }

      els.compareMapSelect.disabled = false;

      // keep current if valid
      if (![...els.compareMapSelect.options].some(o => o.value === els.compareMapSelect.value)){
        els.compareMapSelect.value = GENERAL_MAP_VALUE;
      }
    }

    function updateComparison(){
      const a = els.compareTeamA.value;
      const b = els.compareTeamB.value;
      const mapValue = els.compareMapSelect.value || GENERAL_MAP_VALUE;

      els.teamANameBox.textContent = a || "Team A";
      els.teamBNameBox.textContent = b || "Team B";
      els.probTeamA.textContent = a || "Team A";
      els.probTeamB.textContent = b || "Team B";

      els.h2hHistoryScope.textContent = (mapValue && mapValue !== GENERAL_MAP_VALUE) ? `Scope: ${mapValue}` : "Scope: General";

      if (!a || !b || a === b){
        els.h2hMatchesBox.textContent = "—";
        els.h2hAWinsBox.textContent = "—";
        els.h2hBWinsBox.textContent = "—";
        els.probSourceBox.textContent = "Source: —";
        els.probABox.textContent = "—";
        els.probBBox.textContent = "—";
        els.h2hHint.textContent = "Select two different teams to see their head-to-head record.";
        setH2HBarData(0,0, a||"Team A", b||"Team B");
        setProbDoughnut(50,50, a||"Team A", b||"Team B");
        renderH2HHistory([]);
        return;
      }

      const h2h = getHeadToHead(a, b, mapValue);
      els.h2hMatchesBox.textContent = h2h.total.toString();
      els.h2hAWinsBox.textContent = h2h.aWins.toString();
      els.h2hBWinsBox.textContent = h2h.bWins.toString();

      setH2HBarData(h2h.aWins, h2h.bWins, a, b);

      // Probability logic:
      // 1) If H2H exists on selected map/general -> use Laplace smoothing p=(wins+1)/(total+2)
      // 2) Else fallback to each team's own win rate on selected map/general with Laplace smoothing then normalize.
      let pA = 0.5, pB = 0.5;
      let source = "";

      if (h2h.total > 0){
        const paRaw = (h2h.aWins + 1) / (h2h.total + 2);
        const pbRaw = (h2h.bWins + 1) / (h2h.total + 2);
        const sum = paRaw + pbRaw;
        pA = sum > 0 ? paRaw / sum : 0.5;
        pB = 1 - pA;
        source = `Source: Head-to-head (${mapValue === GENERAL_MAP_VALUE ? "General" : mapValue})`;
        els.probDataHint.textContent =
          `Using head-to-head results for the selected scope. Data: ${a} ${h2h.aWins}W, ${b} ${h2h.bWins}W, total ${h2h.total}.`;
      } else {
        const sA = computeTeamStats(a, mapValue);
        const sB = computeTeamStats(b, mapValue);

        const pARaw = (sA.wins + 1) / (sA.total + 2);
        const pBRaw = (sB.wins + 1) / (sB.total + 2);
        const sum = pARaw + pBRaw;

        pA = sum > 0 ? pARaw / sum : 0.5;
        pB = 1 - pA;

        source = `Source: Win rate fallback (${mapValue === GENERAL_MAP_VALUE ? "General" : mapValue})`;
        els.probDataHint.textContent =
          `No head-to-head matches found for this scope. Fallback uses each team's win rate: ` +
          `${a} ${sA.wins}W-${sA.losses}L (${sA.total}), ${b} ${sB.wins}W-${sB.losses}L (${sB.total}).`;
      }

      els.probSourceBox.textContent = source;
      els.probABox.textContent = `${(pA*100).toFixed(1)}%`;
      els.probBBox.textContent = `${(pB*100).toFixed(1)}%`;

      setProbDoughnut(pA*100, pB*100, a, b);

      // History list (last 5 H2H matches)
      const history = getH2HHistory(a, b, 5, mapValue);
      renderH2HHistory(history);

      // small hint
      els.h2hHint.textContent =
        h2h.total > 0
          ? `Head-to-head found: ${h2h.aWins}–${h2h.bWins} (${h2h.total} matches).`
          : `No head-to-head matches found for this scope.`;
    }

    function getHeadToHead(a, b, mapValue){
      const mapFilter = (mapValue && mapValue !== GENERAL_MAP_VALUE) ? mapValue : null;
      let aWins = 0, bWins = 0, total = 0;

      for (const m of allMatches){
        if (mapFilter && m.map !== mapFilter) continue;

        const isPair =
          (m.team1 === a && m.team2 === b) ||
          (m.team1 === b && m.team2 === a);

        if (!isPair) continue;

        // determine winner among a/b
        const winner = getWinnerTeamName(m);
        if (winner === a) aWins++;
        else if (winner === b) bWins++;

        // count only decisive games (ties are ignored)
        if (winner === a || winner === b) total++;
      }

      return { aWins, bWins, total };
    }

    function getWinnerTeamName(match){
      if (match.winnerSide === "Tie") return "Tie";
      if (match.winnerSide === "Team 1") return match.team1;
      if (match.winnerSide === "Team 2") return match.team2;
      return "Tie";
    }

    function getH2HHistory(a, b, n, mapValue){
      const mapFilter = (mapValue && mapValue !== GENERAL_MAP_VALUE) ? mapValue : null;
      const out = [];

      for (let i = allMatches.length - 1; i >= 0 && out.length < n; i--){
        const m = allMatches[i];
        if (mapFilter && m.map !== mapFilter) continue;

        const isPair =
          (m.team1 === a && m.team2 === b) ||
          (m.team1 === b && m.team2 === a);

        if (!isPair) continue;

        const winner = getWinnerTeamName(m);
        const winBadge = winner === a ? "ok" : (winner === b ? "danger" : "neutral");
        const winText = winner === a ? `Winner: ${a}` : (winner === b ? `Winner: ${b}` : "Winner: Tie");

        out.push({
          map: m.map,
          score: `${m.score1}x${m.score2}`,
          team1: m.team1,
          team2: m.team2,
          winner,
          winBadge,
          winText
        });
      }

      return out;
    }

    function renderH2HHistory(items){
      els.h2hHistoryList.innerHTML = "";

      if (!items.length){
        els.h2hHistoryList.innerHTML = `
          <div class="matchItem">
            <div class="matchLeft">
              <div class="matchLine1">
                <span class="badge neutral">No history</span>
                <span class="matchVs">No head-to-head matches for this scope.</span>
              </div>
            </div>
          </div>`;
        return;
      }

      for (const it of items){
        const row = document.createElement("div");
        row.className = "matchItem";
        row.innerHTML = `
          <div class="matchLeft">
            <div class="matchLine1">
              <span class="badge ${it.winBadge}">${escapeHtml(it.winText)}</span>
              <span class="matchVs">${escapeHtml(it.team1)} vs ${escapeHtml(it.team2)}</span>
            </div>
            <div class="matchLine2">
              <span class="badge neutral">${escapeHtml(it.map)}</span>
              <span class="badge neutral">${escapeHtml(it.score)}</span>
            </div>
          </div>
          <div class="matchRight">
            <span class="badge neutral">${escapeHtml(it.score)}</span>
          </div>`;
        els.h2hHistoryList.appendChild(row);
      }
    }

    function setH2HBarData(aWins, bWins, aName, bName){
      h2hBarChart.data.labels = [aName, bName];
      h2hBarChart.data.datasets[0].data = [aWins, bWins];
      h2hBarChart.update();
    }

    function setProbDoughnut(aPct, bPct, aName, bName){
      probDoughnut.data.labels = [aName, bName];
      probDoughnut.data.datasets[0].data = [aPct, bPct];
      probDoughnut.update();
    }

    /* ----------------------------
       CHARTS BUILD
    -----------------------------*/
    function buildCharts(){
      // Chart 1: team W/L
      const ctx1 = els.wlCanvas.getContext("2d");
      wlChart = new Chart(ctx1, {
        type: "bar",
        data: {
          labels: ["Wins", "Losses"],
          datasets: [{
            label: "Matches",
            data: [0, 0],
            backgroundColor: ["rgba(46, 229, 157, 0.45)","rgba(255, 77, 109, 0.45)"],
            borderColor: ["rgba(46, 229, 157, 0.85)","rgba(255, 77, 109, 0.85)"],
            borderWidth: 1.2,
            borderRadius: 10,
            maxBarThickness: 70
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false } },
          scales: {
            x: { ticks: { color: "rgba(255,255,255,0.80)" }, grid: { color: "rgba(255,255,255,0.06)" } },
            y: { beginAtZero: true, ticks: { color: "rgba(255,255,255,0.80)" }, grid: { color: "rgba(255,255,255,0.06)" } }
          }
        }
      });

      // Chart 2: maps played
      const ctx2 = els.mapPlayCanvas.getContext("2d");
      mapPlayChart = new Chart(ctx2, {
        type: "bar",
        data: { labels: [], datasets: [{
          label: "Matches played",
          data: [],
          backgroundColor: "rgba(124, 92, 255, 0.35)",
          borderColor: "rgba(124, 92, 255, 0.85)",
          borderWidth: 1.1,
          borderRadius: 10
        }]},
        options: {
          indexAxis: "y",
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx)=>` ${ctx.raw} matches` } } },
          scales: {
            x: { beginAtZero: true, ticks: { color: "rgba(255,255,255,0.80)" }, grid: { color: "rgba(255,255,255,0.06)" } },
            y: { ticks: { color: "rgba(255,255,255,0.80)" }, grid: { color: "rgba(255,255,255,0.00)" } }
          }
        }
      });

      // NEW Chart 3: H2H bar
      const ctx3 = els.h2hBarCanvas.getContext("2d");
      h2hBarChart = new Chart(ctx3, {
        type: "bar",
        data: {
          labels: ["Team A", "Team B"],
          datasets: [{
            label: "Head-to-head wins",
            data: [0, 0],
            backgroundColor: ["rgba(124, 92, 255, 0.40)","rgba(35, 213, 171, 0.30)"],
            borderColor: ["rgba(124, 92, 255, 0.85)","rgba(35, 213, 171, 0.80)"],
            borderWidth: 1.1,
            borderRadius: 10,
            maxBarThickness: 70
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false } },
          scales: {
            x: { ticks: { color: "rgba(255,255,255,0.80)" }, grid: { color: "rgba(255,255,255,0.06)" } },
            y: { beginAtZero: true, ticks: { color: "rgba(255,255,255,0.80)" }, grid: { color: "rgba(255,255,255,0.06)" } }
          }
        }
      });

      // NEW Chart 4: probability doughnut
      const ctx4 = els.probCanvas.getContext("2d");
      probDoughnut = new Chart(ctx4, {
        type: "doughnut",
        data: {
          labels: ["Team A", "Team B"],
          datasets: [{
            data: [50, 50],
            backgroundColor: ["rgba(46, 229, 157, 0.45)", "rgba(255, 77, 109, 0.45)"],
            borderColor: ["rgba(46, 229, 157, 0.85)", "rgba(255, 77, 109, 0.85)"],
            borderWidth: 1.1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              labels: { color: "rgba(255,255,255,0.80)" }
            },
            tooltip: {
              callbacks: {
                label: (ctx) => ` ${ctx.label}: ${ctx.raw.toFixed(1)}%`
              }
            }
          }
        }
      });
    }

    /* ----------------------------
       COMPARISON MAP OPTIONS (call once when teams exist)
    -----------------------------*/
    function rebuildCompareMapOptions(){
      // this function exists above; keep as alias for ordering safety
      // (already defined above in this script)
    }

    /* ----------------------------
       EXCEL LOADING
    -----------------------------*/
    async function loadExcelMatches(path, forceReload){
      const url = forceReload ? `${path}?v=${Date.now()}` : path;
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} while fetching ${url}`);

      const buf = await res.arrayBuffer();
      const wb = XLSX.read(buf, { type: "array" });

      const firstSheetName = wb.SheetNames[0];
      if (!firstSheetName) throw new Error("No sheets found in workbook");

      const ws = wb.Sheets[firstSheetName];
      const rows = XLSX.utils.sheet_to_json(ws, { defval: "" });

      const keys = rows.length ? Object.keys(rows[0]) : [];
      const hasExpected = EXPECTED_HEADERS.every(h => keys.includes(h));
      if (!hasExpected) console.warn("Unexpected headers detected:", keys);

      return rows
        .filter(r => (r["Team 1"] || r["Team 2"] || r["Map"] || r["Result"]))
        .map(normalizeRow)
        .filter(Boolean);
    }

    function normalizeRow(r){
      const team1 = String(r["Team 1"] ?? "").trim();
      const team2 = String(r["Team 2"] ?? "").trim();
      const map   = String(r["Map"] ?? "").trim();
      const resultRaw = String(r["Result"] ?? "").trim();

      const { s1, s2 } = parseResult(resultRaw);
      if (!team1 || !team2 || !map || s1 === null || s2 === null) return null;

      let winnerSide = "Team 1";
      let winner = team1;
      if (s2 > s1){ winnerSide = "Team 2"; winner = team2; }
      else if (s1 === s2){ winnerSide = "Tie"; winner = "Tie"; }

      return { team1, team2, map, score1: s1, score2: s2, winnerSide, winner, resultRaw };
    }

    function parseResult(text){
      const cleaned = String(text).replace(/\s+/g, "");
      const m = cleaned.match(/^(\d+)x(\d+)$/i);
      if (!m) return { s1: null, s2: null };
      return { s1: Number(m[1]), s2: Number(m[2]) };
    }

    function escapeHtml(str){
      return String(str)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }
  </script>
</body>
</html>