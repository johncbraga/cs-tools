<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VRS Rating</title>

  <!-- SheetJS (XLSX) - CDN -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --card:#121a2b;
      --muted:#8aa0c2;
      --text:#eaf0ff;
      --line:#22304d;
      --good:#39d98a;
      --bad:#ff5c7a;
      --warn:#ffd36a;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    body{
      margin:0; padding:24px;
      font-family:var(--sans);
      background:radial-gradient(1200px 600px at 20% 0%, #172449 0%, var(--bg) 60%);
      color:var(--text);
    }
    h1{margin:0 0 8px 0; font-size:22px}
    p{margin:0 0 16px 0; color:var(--muted); line-height:1.4}
    .grid{
      display:grid;
      gap:14px;
      grid-template-columns: 1fr;
      max-width:1100px;
      margin:0 auto;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:16px;
      padding:16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .row{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:end;
    }
    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="file"], input[type="text"], select{
      width: 320px;
      max-width:100%;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid var(--line);
      background:#0c1426;
      color:var(--text);
      outline:none;
    }
    input[type="text"]{width: 260px;}
    select{width: 220px;}
    button{
      padding:10px 14px;
      border-radius:10px;
      border:1px solid transparent;
      background: linear-gradient(180deg, rgba(122,162,255,.95), rgba(122,162,255,.75));
      color:#061022;
      font-weight:700;
      cursor:pointer;
      transition: transform .05s ease, filter .2s ease;
    }
    button:active{transform: translateY(1px);}
    button.secondary{
      background:#0c1426;
      color:var(--text);
      border-color: var(--line);
      font-weight:600;
    }
    .hint{
      font-size:12px; color:var(--muted);
      margin-top:10px;
    }
    .status{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px dashed var(--line);
      background:rgba(0,0,0,.15);
      color:var(--muted);
      font-family:var(--mono);
      white-space:pre-wrap;
    }
    .badges{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .badge{
      border:1px solid var(--line);
      background:rgba(0,0,0,.15);
      padding:8px 10px;
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
    }
    .badge strong{color:var(--text); font-family:var(--mono)}

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.15);
    }
    thead th{
      text-align:left;
      font-size:12px;
      color:var(--muted);
      padding:12px 10px;
      border-bottom:1px solid var(--line);
      position:sticky; top:0;
      background:rgba(10,16,32,.85);
      backdrop-filter: blur(6px);
      z-index:2;
    }
    tbody td{
      padding:10px 10px;
      border-bottom:1px solid rgba(34,48,77,.6);
      font-size:14px;
    }
    tbody tr:hover{filter: brightness(1.06);}

    @keyframes waveMove {
      0%   { background-position: 0% 50%; }
      50%  { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    @keyframes shimmer {
      0%   { transform: translateX(-40%) skewX(-10deg); opacity: .14; }
      50%  { opacity: .26; }
      100% { transform: translateX(140%) skewX(-10deg); opacity: .14; }
    }

    tbody tr.wave{
      position: relative;
      isolation: isolate;
      background-size: 380% 380%;
      animation: waveMove 7s ease-in-out infinite;
    }
    tbody tr.wave::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:0;
      background: linear-gradient(90deg,
        rgba(255,255,255,0) 0%,
        rgba(255,255,255,.18) 50%,
        rgba(255,255,255,0) 100%
      );
      mix-blend-mode: overlay;
      transform: translateX(-40%) skewX(-10deg);
      animation: shimmer 3.4s linear infinite;
    }
    tbody tr.wave > td{ position: relative; z-index:1; }

    tbody tr.top1{
      background-image: linear-gradient(120deg,
        rgba(255, 220, 90, .42),
        rgba(255, 190, 20, .55),
        rgba(255, 240, 160, .40),
        rgba(190, 120, 0, .38)
      );
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.08),
        0 0 0 1px rgba(255,215,100,.10);
    }

    tbody tr.top2{
      background-image: linear-gradient(120deg,
        rgba(250,250,255,.38),
        rgba(200,210,230,.50),
        rgba(255,255,255,.38),
        rgba(160,170,190,.36)
      );
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
    }

    tbody tr.top3{
      background-image: linear-gradient(120deg,
        rgba(255, 180, 110, .34),
        rgba(205, 127, 50, .50),
        rgba(255, 210, 160, .32),
        rgba(140, 70, 20, .36)
      );
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.07);
    }

    tbody tr.top4to10{
      background-image: linear-gradient(120deg,
        rgba(255,55,95,.35),
        rgba(255,140,60,.28),
        rgba(255,55,95,.35),
        rgba(120,0,25,.28)
      );
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.05);
    }

    @keyframes textWave{
      0%   { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }

    .teamName{
      display:inline-block;
      font-weight: 900;
      letter-spacing: .15px;
      background-size: 320% 100%;
      animation: textWave 4s linear infinite;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      -webkit-text-fill-color: transparent;
    }

    .name-top1{
      background-image: linear-gradient(90deg,
        #00ffae,
        #00d7ff,
        #00a3ff,
        #7a5cff,
        #ff3cc8,
        #ff66d9,
        #00ffae
      );
    }

    .name-top2{
      background-image: linear-gradient(90deg,
        #00ff9a, #000000, #5cffc1, #0b0b0f, #00ff9a
      );
    }

    .name-top3{
      background-image: linear-gradient(90deg,
        #000000, #5a00ff, #0b0b0f, #b46cff, #000000
      );
    }

    .name-top4to10{
      background-image: linear-gradient(90deg,
        #ff4d4d, #ff9f43, #ff4d4d
      );
      font-weight:800;
      text-shadow: 0 2px 10px rgba(0,0,0,.35);
    }

    .mono{font-family:var(--mono);}
    .delta{
      font-family:var(--mono);
      font-weight:800;
      letter-spacing:.2px;
    }
    .up{color:var(--good);}
    .down{color:var(--bad);}
    .flat{color:var(--muted);}
    .new{color:var(--warn);}
    .right{text-align:right;}
    .small{font-size:12px; color:var(--muted);}
    .footer{
      color:var(--muted);
      font-size:12px;
      margin-top:10px;
      line-height:1.4;
    }

    @media (prefers-reduced-motion: reduce){
      tbody tr.wave{ animation: none !important; }
      tbody tr.wave::after{ animation: none !important; }
      .teamName{ animation: none !important; }
    }

    .backToMenu{
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 9999;
      padding:10px 14px;
      border-radius:10px;
      border:1px solid var(--line);
      background:#0c1426;
      color:var(--text);
      font-weight:700;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      gap:10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .backToMenu:hover{ filter: brightness(1.08); }
    .backToMenu:active{ transform: translateY(1px); }
  </style>
</head>

<body>
  <a class="backToMenu" href="index.html">← Back to Menu</a>

  <div class="grid">
    <div class="card">
      <h1>VRS Rating</h1>
      <p>
        Rating by <span class="mono">Points</span>.
        Filter for <span class="mono">Region</span> and <span class="mono">Tier</span> avaliable.
      </p>

      <div class="row">
        <div style="min-width:320px;">
          <label>Old Rating source</label>
          <div class="hint"><span class="mono">file/old.xlsx</span></div>
        </div>

        <div style="min-width:320px;">
          <label>New Rating source</label>
          <div class="hint"><span class="mono">file/ranking.xlsx</span> (fallback: <span class="mono">file/ranking.xlsx</span>)</div>
        </div>

        <div style="display:flex; gap:10px; align-items:end; flex-wrap:wrap;">
          <button id="btnCompare">Compare</button>
          <button class="secondary" id="btnUpdateOld">Update Old</button>
          <button class="secondary" id="btnUpdateNew">Update New</button>
          <button class="secondary" id="btnDownloadCsv" disabled>Download CSV</button>
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <div>
          <label>Filter by Region</label>
          <select id="filterRegion" disabled>
            <option value="">Global</option>
          </select>
        </div>
        <div>
          <label>Filter by Tier</label>
          <select id="filterTier" disabled>
            <option value="">All</option>
            <option value="Tier S">Tier S</option>
            <option value="Tier 1">Tier 1</option>
            <option value="Tier 2">Tier 2</option>
            <option value="Tier 3">Tier 3</option>
          </select>
        </div>
        <div style="margin-left:auto;">
          <label>Filter by team (text)</label>
          <input id="filterText" type="text" placeholder="Digite parte do nome..." disabled />
        </div>
        <div style="display:flex; gap:10px; align-items:end;">
          <button class="secondary" id="btnClearFilters" disabled>Clear filters</button>
        </div>
      </div>

      <div class="hint">
        Excel must follow: <span class="mono">Team | Points | Tier | Region</span>.
      </div>

      <div id="status" class="status">Carregando arquivos automaticamente…</div>

      <div class="badges" id="badges" style="display:none;">
        <div class="badge">Teams: <strong id="countTeams">0</strong></div>
        <div class="badge">Rise: <strong id="countUp">0</strong></div>
        <div class="badge">Descend: <strong id="countDown">0</strong></div>
        <div class="badge">No Change: <strong id="countFlat">0</strong></div>
        <div class="badge">New Teams: <strong id="countNew">0</strong></div>
      </div>
    </div>

    <div class="card">
      <div class="small" style="margin-bottom:10px;">
        VRS Rating<br/>
        02/17/2026
      </div>

      <div style="overflow:auto; max-height: 70vh;">
        <table>
          <thead>
            <tr>
              <th class="right">Posição</th>
              <th>Team</th>
              <th class="right">Points</th>
              <th class="right">Points Diff</th>
              <th>Region</th>
              <th>Tier</th>
              <th class="right">Indicador</th>
              <th class="right small">Old → New</th>
            </tr>
          </thead>
          <tbody id="tbody">
            <tr><td colspan="8" class="small">Nenhum dado ainda. Carregue os arquivos e clique em “Comparar”.</td></tr>
          </tbody>
        </table>
      </div>

      <div class="footer">
        Everything runs locally in the browser.
      </div>
    </div>

    <!-- ✅ ADIÇÃO: Region-grouped table (English) -->
    <div class="card">
      <div class="small" style="margin-bottom:10px;">
        VRS Rating — Region Ranking<br/>
        02/17/2026
      </div>

      <div class="row" style="margin-bottom:12px;">
        <div>
          <label>Select Region</label>
          <select id="regionRankingSelect" disabled>
            <option value="">—</option>
          </select>
        </div>
      </div>

      <div style="overflow:auto; max-height: 70vh;">
        <table>
          <thead>
            <tr>
              <th class="right">Position</th>
              <th>Team</th>
              <th class="right">Points</th>
              <th class="right">Points Diff</th>
              <th>Region</th>
              <th>Tier</th>
              <th class="right">Indicator</th>
              <th class="right small">Old → New</th>
            </tr>
          </thead>
          <tbody id="tbodyRegion">
            <tr><td colspan="8" class="small">No data yet. Load the files and click “Compare”.</td></tr>
          </tbody>
        </table>
      </div>

      <div class="footer">
        This table ranks teams within the selected region and computes movement (Old → New) within that region.
      </div>
    </div>
    <!-- ✅ FIM ADIÇÃO -->

    <!-- ✅ ADIÇÃO: Match Predictor (English) -->
    <div class="card">
      <div class="small" style="margin-bottom:10px;">
        VRS Rating — Match Predictor<br/>
        02/17/2026
      </div>

      <div class="row" style="margin-bottom:12px;">
        <div>
          <label>Select Team A</label>
          <select id="matchTeamA" disabled>
            <option value="">—</option>
          </select>
        </div>

        <div>
          <label>Select Team B</label>
          <select id="matchTeamB" disabled>
            <option value="">—</option>
          </select>
        </div>

        <div>
          <label>Result</label>
          <select id="matchResult" disabled>
            <option value="A">Team A wins</option>
            <option value="B">Team B wins</option>
          </select>
        </div>
      </div>

      <div id="matchStatus" class="status">Select two teams to preview point and ranking changes.</div>

      <div style="overflow:auto; max-height: 55vh;">
        <table>
          <thead>
            <tr>
              <th class="right">Current Pos</th>
              <th>Team</th>
              <th class="right">Current Points</th>
              <th class="right">Streak</th>
              <th class="right">Δ Points</th>
              <th class="right">New Points</th>
              <th class="right">Movement</th>
              <th class="right small">Old → New</th>
            </tr>
          </thead>
          <tbody id="tbodyMatchPredict">
            <tr><td colspan="8" class="small">No selection yet.</td></tr>
          </tbody>
        </table>
      </div>

      <div class="footer">
        Rules: Win = + (8 + current streak). Loss = -5. After win streak becomes streak+1; after loss streak becomes 0.
      </div>
    </div>
    <!-- ✅ FIM ADIÇÃO -->

  </div>

  <script>
    const $ = (sel) => document.querySelector(sel);

    const REGION_LABELS = {
      "AM": "Americas",
      "EU": "Europa",
      "AS/SIS/ESEA": "Asia"
    };

    const OLD_URL = "file/old.xlsx";
    const NEW_URL_PRIMARY = "file/ranking.xlsx";
    const NEW_URL_FALLBACK = "file/ranking.xlsx";

    let oldRowsCache = null;
    let newRowsCache = null;

    // ✅ ADIÇÃO: keep a copy of the latest NEW ranking objects (with streak, etc.)
    let currentNewTeams = null;

    async function readExcelFromUrl(url){
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} ao buscar ${url}`);
      const data = await res.arrayBuffer();
      const wb = XLSX.read(data, { type: "array" });
      const sheetName = wb.SheetNames[0];
      const ws = wb.Sheets[sheetName];
      return XLSX.utils.sheet_to_json(ws, { defval: "", raw: true });
    }

    async function loadOld(force=false){
      const bust = force ? `?v=${Date.now()}` : "";
      const url = OLD_URL + bust;
      oldRowsCache = await readExcelFromUrl(url);
      return true;
    }

    async function loadNew(force=false){
      const bust = force ? `?v=${Date.now()}` : "";
      try{
        newRowsCache = await readExcelFromUrl(NEW_URL_PRIMARY + bust);
        return "primary";
      }catch(e){
        newRowsCache = await readExcelFromUrl(NEW_URL_FALLBACK + bust);
        return "fallback";
      }
    }

    function normalizeHeader(h){ return String(h || "").trim().toLowerCase(); }

    function getColumn(row, headerMap, desired){
      const candidates = {
        team:     ["team", "time", "equipe"],
        points:   ["points", "pontos"],
        tier:     ["tier"],
        region:   ["region", "região", "regiao"],
        victories:["victories", "vitorias", "vitórias"],
        streak:   ["streak", "sequencia", "sequência"],
        loses:    ["loses", "losses", "derrotas", "perdas"]
      }[desired];

      for (const c of candidates){
        const key = headerMap[c];
        if (key !== undefined) return row[key];
      }
      return undefined;
    }

    function toNumber(v){
      if (v === null || v === undefined) return NaN;
      if (typeof v === "number") return v;
      const s = String(v).replace(/\./g, "").replace(/,/g, ".").trim();
      const n = Number(s);
      return Number.isFinite(n) ? n : NaN;
    }

    // ✅ ÚNICA MUDANÇA (Points display as INT): helper só pra exibição
    function pointsIntDisplay(v){
      // aceita number ou string com vírgula/ponto; retorna inteiro (truncado)
      const n = (typeof v === "number") ? v : toNumber(v);
      const i = Math.trunc(Number(n));
      return Number.isFinite(i) ? i : 0;
    }

    function buildHeaderMap(rows){
      const map = {};
      const sample = rows[0] || {};
      Object.keys(sample).forEach((k) => { map[normalizeHeader(k)] = k; });
      return map;
    }

    function buildRanking(rows){
      const headerMap = buildHeaderMap(rows);
      const teams = [];

      for (const r of rows){
        const team = String(getColumn(r, headerMap, "team") ?? "").trim();
        if (!team) continue;

        const points = toNumber(getColumn(r, headerMap, "points"));
        const tier = String(getColumn(r, headerMap, "tier") ?? "").trim();
        const region = String(getColumn(r, headerMap, "region") ?? "").trim();

        // ✅ ADIÇÃO: optional columns used by Match Predictor
        const victories = toNumber(getColumn(r, headerMap, "victories"));
        const streak = toNumber(getColumn(r, headerMap, "streak"));
        const loses = toNumber(getColumn(r, headerMap, "loses"));

        teams.push({
          team,
          points: Number.isFinite(points) ? points : 0,
          tier,
          region,
          victories: Number.isFinite(victories) ? victories : 0,
          streak: Number.isFinite(streak) ? streak : 0,
          loses: Number.isFinite(loses) ? loses : 0
        });
      }

      teams.sort((a,b) => {
        if (b.points !== a.points) return b.points - a.points;
        return a.team.localeCompare(b.team, "pt-BR");
      });

      teams.forEach((t, idx) => t.pos = idx + 1);
      return teams;
    }

    function mapPositions(teams){
      const map = new Map();
      for (const t of teams){ map.set(t.team.toLowerCase(), t.pos); }
      return map;
    }

    function mapPoints(teams){
      const map = new Map();
      for (const t of teams){ map.set(t.team.toLowerCase(), t.points); }
      return map;
    }

    function computeDelta(oldPos, newPos){
      const d = oldPos - newPos;
      if (d === 0) return { text: "0", cls: "flat" };
      if (d > 0) return { text: "+" + d, cls: "up" };
      return { text: "-" + Math.abs(d), cls: "down" };
    }

    function computePointsDiff(oldPoints, newPoints){
      const diff = newPoints - oldPoints;
      if (diff === 0) return { text: "0", cls: "flat" };
      if (diff > 0) return { text: "+" + diff, cls: "up" };
      return { text: "-" + Math.abs(diff), cls: "down" };
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&amp;amp;amp;","&amp;amp;amp;amp;")
        .replaceAll("&amp;lt;","&amp;amp;lt;")
        .replaceAll("&amp;gt;","&amp;amp;gt;")
        .replaceAll('"',"&amp;amp;quot;")
        .replaceAll("'","&amp;amp;#039;");
    }

    function regionLabel(regionValue){
      return REGION_LABELS[regionValue] || regionValue || "";
    }

    function updateRegionFilterOptions(combined){
      const select = $("#filterRegion");
      const current = select.value;

      const regions = new Set();
      for (const r of combined){ if (r.region) regions.add(r.region); }

      const preferredOrder = ["AM","EU","AS/SIS/ESEA"];
      const list = Array.from(regions).sort((a,b) => {
        const ia = preferredOrder.indexOf(a);
        const ib = preferredOrder.indexOf(b);
        if (ia !== -1 || ib !== -1){
          return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
        }
        return a.localeCompare(b, "pt-BR");
      });

      select.innerHTML = `<option value="">Todas</option>` + list
        .map(v => `<option value="${escapeHtml(v)}">${escapeHtml(regionLabel(v))}</option>`)
        .join("");

      select.value = list.includes(current) ? current : "";
    }

    function applyFilters(combined){
      const filterText = $("#filterText").value.trim().toLowerCase();
      const region = $("#filterRegion").value;
      const tier = $("#filterTier").value;

      return combined.filter(r => {
        const okText = !filterText || r.team.toLowerCase().includes(filterText);
        const okRegion = !region || r.region === region;
        const okTier = !tier || r.tier === tier;
        return okText && okRegion && okTier;
      });
    }

    function renderTable(combined){
      const tbody = $("#tbody");
      const rows = applyFilters(combined);

      if (!rows.length){
        tbody.innerHTML = `<tr><td colspan="8" class="small">Nenhum resultado para os filtros atuais.</td></tr>`;
        return;
      }

      tbody.innerHTML = rows.map(r => {
        const oldToNew = (r.oldPos ? r.oldPos : "—") + " → " + r.newPos;

        const deltaCell = r.deltaText === "NEW"
          ? `<span class="delta new">NEW</span>`
          : `<span class="delta ${r.deltaCls}">${r.deltaText}</span>`;

        const diffCell = r.pointsDiffText === "NEW"
          ? `<span class="delta new">NEW</span>`
          : `<span class="delta ${r.pointsDiffCls}">${r.pointsDiffText}</span>`;

        let rowClass = "";
        if (r.newPos === 1) rowClass = "top1 wave";
        else if (r.newPos === 2) rowClass = "top2 wave";
        else if (r.newPos === 3) rowClass = "top3 wave";
        else if (r.newPos >= 4 && r.newPos <= 10) rowClass = "top4to10 wave";

        let nameClass = "";
        if (r.newPos === 1) nameClass = "name-top1";
        else if (r.newPos === 2) nameClass = "name-top2";
        else if (r.newPos === 3) nameClass = "name-top3";
        else if (r.newPos >= 4 && r.newPos <= 10) nameClass = "name-top4to10";

        const teamHtml = nameClass
          ? `<span class="teamName ${nameClass}">${escapeHtml(r.team)}</span>`
          : `${escapeHtml(r.team)}`;

        return `
          <tr class="${rowClass}">
            <td class="right mono">${r.newPos}</td>
            <td>${teamHtml}</td>
            <td class="right mono">${pointsIntDisplay(r.points)}</td> <!-- ✅ Points como INT (somente exibição) -->
            <td class="right mono">${diffCell}</td>
            <td>${escapeHtml(regionLabel(r.region))}</td>
            <td>${escapeHtml(r.tier || "")}</td>
            <td class="right">${deltaCell}</td>
            <td class="right mono small">${oldToNew}</td>
          </tr>
        `;
      }).join("");
    }

    function toCsv(combined){
      const header = ["Posição","Team","Points","Points Diff","Region","Tier","Indicador","OldPos","NewPos"];
      const lines = [header.join(",")];
      for (const r of combined){
        const vals = [
          r.newPos,
          `"${String(r.team).replaceAll('"','""')}"`,
          r.points,
          r.pointsDiffText,
          `"${String(r.region||"").replaceAll('"','""')}"`,
          `"${String(r.tier||"").replaceAll('"','""')}"`,
          r.deltaText,
          r.oldPos ?? "",
          r.newPos
        ];
        lines.push(vals.join(","));
      }
      return lines.join("\n");
    }

    function downloadText(filename, content, mime="text/plain"){
      const blob = new Blob([content], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    let lastCombined = null;

    function enableFilters(enabled){
      $("#filterRegion").disabled = !enabled;
      $("#filterTier").disabled = !enabled;
      $("#filterText").disabled = !enabled;
      $("#btnClearFilters").disabled = !enabled;
    }

    /* ✅ ADIÇÃO: Region Ranking state + helpers */
    let lastRegionCombined = null;

    function updateRegionRankingSelectOptions(combined){
      const select = $("#regionRankingSelect");
      const current = select.value;

      const regions = new Set();
      for (const r of combined){ if (r.region) regions.add(r.region); }

      const preferredOrder = ["AM","EU","AS/SIS/ESEA"];
      const list = Array.from(regions).sort((a,b) => {
        const ia = preferredOrder.indexOf(a);
        const ib = preferredOrder.indexOf(b);
        if (ia !== -1 || ib !== -1){
          return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
        }
        return a.localeCompare(b, "pt-BR");
      });

      select.innerHTML = list.length
        ? list.map(v => `<option value="${escapeHtml(v)}">${escapeHtml(regionLabel(v))}</option>`).join("")
        : `<option value="">—</option>`;

      if (list.includes(current)) select.value = current;
      else select.value = list[0] || "";
    }

    function computeRegionCombined(regionValue){
      if (!oldRowsCache || !newRowsCache) return [];

      const oldHeaderMap = buildHeaderMap(oldRowsCache || []);
      const newHeaderMap = buildHeaderMap(newRowsCache || []);

      const oldFiltered = (oldRowsCache || []).filter(rr => {
        const reg = String(getColumn(rr, oldHeaderMap, "region") ?? "").trim();
        return reg === regionValue;
      });
      const newFiltered = (newRowsCache || []).filter(rr => {
        const reg = String(getColumn(rr, newHeaderMap, "region") ?? "").trim();
        return reg === regionValue;
      });

      const oldTeamsR = buildRanking(oldFiltered);
      const newTeamsR = buildRanking(newFiltered);

      const oldPosMapR = mapPositions(oldTeamsR);
      const oldPointsMapR = mapPoints(oldTeamsR);

      const combinedR = newTeamsR.map(t => {
        const key = t.team.toLowerCase();
        const oldPos = oldPosMapR.get(key);
        const oldPts = oldPointsMapR.get(key);

        let posDelta = { text: "NEW", cls: "new" };
        if (oldPos){
          posDelta = computeDelta(oldPos, t.pos);
        }

        let ptsDelta = { text: "NEW", cls: "new" };
        if (oldPts !== undefined){
          ptsDelta = computePointsDiff(oldPts, t.points);
        }

        return {
          team: t.team,
          points: t.points,
          region: t.region,
          tier: t.tier,
          oldPos: oldPos ?? null,
          newPos: t.pos,
          deltaText: oldPos ? posDelta.text : "NEW",
          deltaCls: oldPos ? posDelta.cls : "new",
          pointsDiffText: (oldPts !== undefined) ? ptsDelta.text : "NEW",
          pointsDiffCls: (oldPts !== undefined) ? ptsDelta.cls : "new"
        };
      });

      return combinedR;
    }

    function renderRegionTable(regionCombined){
      const tbody = $("#tbodyRegion");

      if (!regionCombined || !regionCombined.length){
        tbody.innerHTML = `<tr><td colspan="8" class="small">No results for the selected region.</td></tr>`;
        return;
      }

      tbody.innerHTML = regionCombined.map(r => {
        const oldToNew = (r.oldPos ? r.oldPos : "—") + " → " + r.newPos;

        const deltaCell = r.deltaText === "NEW"
          ? `<span class="delta new">NEW</span>`
          : `<span class="delta ${r.deltaCls}">${r.deltaText}</span>`;

        const diffCell = r.pointsDiffText === "NEW"
          ? `<span class="delta new">NEW</span>`
          : `<span class="delta ${r.pointsDiffCls}">${r.pointsDiffText}</span>`;

        let rowClass = "";
        if (r.newPos === 1) rowClass = "top1 wave";
        else if (r.newPos === 2) rowClass = "top2 wave";
        else if (r.newPos === 3) rowClass = "top3 wave";
        else if (r.newPos >= 4 && r.newPos <= 10) rowClass = "top4to10 wave";

        let nameClass = "";
        if (r.newPos === 1) nameClass = "name-top1";
        else if (r.newPos === 2) nameClass = "name-top2";
        else if (r.newPos === 3) nameClass = "name-top3";
        else if (r.newPos >= 4 && r.newPos <= 10) nameClass = "name-top4to10";

        const teamHtml = nameClass
          ? `<span class="teamName ${nameClass}">${escapeHtml(r.team)}</span>`
          : `${escapeHtml(r.team)}`;

        return `
          <tr class="${rowClass}">
            <td class="right mono">${r.newPos}</td>
            <td>${teamHtml}</td>
            <td class="right mono">${pointsIntDisplay(r.points)}</td> <!-- ✅ Points como INT (somente exibição) -->
            <td class="right mono">${diffCell}</td>
            <td>${escapeHtml(regionLabel(r.region))}</td>
            <td>${escapeHtml(r.tier || "")}</td>
            <td class="right">${deltaCell}</td>
            <td class="right mono small">${oldToNew}</td>
          </tr>
        `;
      }).join("");
    }

    function enableRegionRanking(enabled){
      $("#regionRankingSelect").disabled = !enabled;
    }

    function recomputeRegionRanking(){
      const regionValue = $("#regionRankingSelect").value;
      if (!regionValue){
        $("#tbodyRegion").innerHTML = `<tr><td colspan="8" class="small">Select a region to display the ranking.</td></tr>`;
        lastRegionCombined = null;
        return;
      }
      const combinedR = computeRegionCombined(regionValue);
      lastRegionCombined = combinedR;
      renderRegionTable(combinedR);
    }
    /* ✅ FIM ADIÇÃO */

    /* ✅ ADIÇÃO: Match Predictor helpers */
    function enableMatchPredictor(enabled){
      $("#matchTeamA").disabled = !enabled;
      $("#matchTeamB").disabled = !enabled;
      $("#matchResult").disabled = !enabled;
    }

    function updateMatchTeamOptions(teams){
      const selA = $("#matchTeamA");
      const selB = $("#matchTeamB");
      const curA = selA.value;
      const curB = selB.value;

      const opts = [`<option value="">—</option>`].concat(
        (teams || []).map(t => `<option value="${escapeHtml(t.team)}">${escapeHtml(t.team)}</option>`)
      ).join("");

      selA.innerHTML = opts;
      selB.innerHTML = opts;

      const names = new Set((teams || []).map(t => t.team));
      selA.value = names.has(curA) ? curA : "";
      selB.value = names.has(curB) ? curB : "";
    }

    function computeHypotheticalRanking(teams, updatesByLowerName){
      const hypo = (teams || []).map(t => ({...t}));

      for (const ht of hypo){
        const key = ht.team.toLowerCase();
        const upd = updatesByLowerName.get(key);
        if (upd){
          ht.points = upd.newPoints;
          ht.streak = upd.newStreak;
        }
      }

      hypo.sort((a,b) => {
        if (b.points !== a.points) return b.points - a.points;
        return a.team.localeCompare(b.team, "pt-BR");
      });

      hypo.forEach((t, idx) => t.pos = idx + 1);
      return hypo;
    }

    /* ===== UPDATED MATCH PREDICTOR LOGIC (ELO + STREAK + TOURNAMENT BONUS) ===== */
    const ELO_K_BASE = 30;
    const ELO_DIVISOR = 400;
    const ELO_STREAK_ALPHA = 0.10;  // max +10% K
    const ELO_STREAK_SCALE = 5;     // tanh(streak/5)
    const ELO_K_CAP_MULT = 1.35;

    const ELO_TOURNEY = {
      regional: { bonus: 0.05 },
      global:   { bonus: 0.10 },
      major:    { bonus: 0.20 }
    };

    function eloExpected(ra, rb){
      return 1 / (1 + Math.pow(10, (rb - ra) / ELO_DIVISOR));
    }
    function tanhLocal(x){
      const e2x = Math.exp(2*x);
      return (e2x - 1) / (e2x + 1);
    }
    function streakKBonus(streak){
      const s = Number.isFinite(streak) ? streak : 0;
      return ELO_STREAK_ALPHA * tanhLocal(s / ELO_STREAK_SCALE);
    }

    function getBonusForTeamLower(lowerName){
      if (!newRowsCache || !newRowsCache.length) return { type: "none", remaining: 0 };

      // Find matching row by team (case-insensitive) without changing other code paths
      const headerMap = buildHeaderMap(newRowsCache);
      for (const r of newRowsCache){
        const t = String(getColumn(r, headerMap, "team") ?? "").trim();
        if (!t) continue;
        if (t.toLowerCase() !== lowerName) continue;

        // Detect optional columns BonusType / BonusRemaining (case-insensitive)
        let bonusTypeKey = null;
        let bonusRemKey = null;
        for (const k of Object.keys(r)){
          const nk = normalizeHeader(k);
          if (nk === "bonustype") bonusTypeKey = k;
          if (nk === "bonusremaining") bonusRemKey = k;
        }
        const type = bonusTypeKey ? String(r[bonusTypeKey] ?? "").trim().toLowerCase() : "none";
        const remaining = bonusRemKey ? toNumber(r[bonusRemKey]) : 0;

        return {
          type: (type === "regional" || type === "global" || type === "major") ? type : "none",
          remaining: Number.isFinite(remaining) ? remaining : 0
        };
      }
      return { type: "none", remaining: 0 };
    }

    function tournamentKBonus(bonusType, bonusRemaining){
      if (!bonusType || bonusType === "none") return 0;
      if (!Number.isFinite(bonusRemaining) || bonusRemaining <= 0) return 0;
      const b = ELO_TOURNEY[bonusType];
      return b ? b.bonus : 0;
    }

    function kFinalFor(team){
      const sBonus = streakKBonus(team.streak || 0);
      const bInfo = getBonusForTeamLower(team.team.toLowerCase());
      const tBonus = tournamentKBonus(bInfo.type, bInfo.remaining);
      const k = ELO_K_BASE * (1 + sBonus) * (1 + tBonus);
      const cap = ELO_K_BASE * ELO_K_CAP_MULT;
      return Math.min(k, cap);
    }

    function renderMatchPredictor(){
      const tbody = $("#tbodyMatchPredict");
      if (!currentNewTeams || !currentNewTeams.length){
        tbody.innerHTML = `<tr><td colspan="8" class="small">No data loaded.</td></tr>`;
        $("#matchStatus").textContent = "Load ranking data to use the predictor.";
        return;
      }

      const aName = $("#matchTeamA").value;
      const bName = $("#matchTeamB").value;
      const result = $("#matchResult").value; // "A" or "B"

      if (!aName || !bName){
        tbody.innerHTML = `<tr><td colspan="8" class="small">No selection yet.</td></tr>`;
        $("#matchStatus").textContent = "Select two teams to preview point and ranking changes.";
        return;
      }
      if (aName === bName){
        tbody.innerHTML = `<tr><td colspan="8" class="small">Pick two different teams.</td></tr>`;
        $("#matchStatus").textContent = "Team A and Team B must be different.";
        return;
      }

      const byName = new Map(currentNewTeams.map(t => [t.team.toLowerCase(), t]));
      const a = byName.get(aName.toLowerCase());
      const b = byName.get(bName.toLowerCase());

      if (!a || !b){
        tbody.innerHTML = `<tr><td colspan="8" class="small">Selected team not found in the current ranking.</td></tr>`;
        $("#matchStatus").textContent = "One or both teams were not found.";
        return;
      }

      const ra = Number(a.points) || 0;
      const rb = Number(b.points) || 0;

      const ea = eloExpected(ra, rb);
      const eb = 1 - ea;

      const kA = kFinalFor(a);
      const kB = kFinalFor(b);

      // Outcome scoring: win=1, loss=0 (predictor currently supports A/B only)
      let aDelta = 0, bDelta = 0;
      let aNewStreak = a.streak, bNewStreak = b.streak;

      if (result === "A"){
        aDelta = kA * (1 - ea);
        bDelta = kB * (0 - eb);
        aNewStreak = (a.streak || 0) + 1;
        bNewStreak = 0;
      } else {
        aDelta = kA * (0 - ea);
        bDelta = kB * (1 - eb);
        aNewStreak = 0;
        bNewStreak = (b.streak || 0) + 1;
      }

      const aNewPoints = ra + aDelta;
      const bNewPoints = rb + bDelta;

      const updates = new Map();
      updates.set(a.team.toLowerCase(), { newPoints: aNewPoints, newStreak: aNewStreak });
      updates.set(b.team.toLowerCase(), { newPoints: bNewPoints, newStreak: bNewStreak });

      const hypo = computeHypotheticalRanking(currentNewTeams, updates);

      const oldPosMap = mapPositions(currentNewTeams);
      const newPosMap = mapPositions(hypo);

      const aOldPos = oldPosMap.get(a.team.toLowerCase());
      const bOldPos = oldPosMap.get(b.team.toLowerCase());
      const aNewPos = newPosMap.get(a.team.toLowerCase());
      const bNewPos = newPosMap.get(b.team.toLowerCase());

      const aMove = computeDelta(aOldPos, aNewPos);
      const bMove = computeDelta(bOldPos, bNewPos);

      const aPtsDiff = computePointsDiff(ra, aNewPoints);
      const bPtsDiff = computePointsDiff(rb, bNewPoints);

      const aMoveCell = `<span class="delta ${aMove.cls}">${aMove.text}</span>`;
      const bMoveCell = `<span class="delta ${bMove.cls}">${bMove.text}</span>`;

      const aPtsCell = `<span class="delta ${aPtsDiff.cls}">${aPtsDiff.text}</span>`;
      const bPtsCell = `<span class="delta ${bPtsDiff.cls}">${bPtsDiff.text}</span>`;

      const rowA = `
        <tr>
          <td class="right mono">${aOldPos}</td>
          <td>${escapeHtml(a.team)}</td>
          <td class="right mono">${pointsIntDisplay(ra)}</td> <!-- ✅ Points como INT (somente exibição) -->
          <td class="right mono">${a.streak}</td>
          <td class="right mono">${aPtsCell}</td>
          <td class="right mono">${pointsIntDisplay(aNewPoints)}</td> <!-- ✅ Points como INT (somente exibição) -->
          <td class="right">${aMoveCell}</td>
          <td class="right mono small">${aOldPos} → ${aNewPos}</td>
        </tr>
      `;

      const rowB = `
        <tr>
          <td class="right mono">${bOldPos}</td>
          <td>${escapeHtml(b.team)}</td>
          <td class="right mono">${pointsIntDisplay(rb)}</td> <!-- ✅ Points como INT (somente exibição) -->
          <td class="right mono">${b.streak}</td>
          <td class="right mono">${bPtsCell}</td>
          <td class="right mono">${pointsIntDisplay(bNewPoints)}</td> <!-- ✅ Points como INT (somente exibição) -->
          <td class="right">${bMoveCell}</td>
          <td class="right mono small">${bOldPos} → ${bNewPos}</td>
        </tr>
      `;

      tbody.innerHTML = rowA + rowB;

      const winner = (result === "A") ? a.team : b.team;
      $("#matchStatus").textContent =
        `Scenario: ${winner} wins. ` +
        `${a.team}: ${aPtsDiff.text} pts, ${aOldPos}→${aNewPos} (${aMove.text}). ` +
        `${b.team}: ${bPtsDiff.text} pts, ${bOldPos}→${bNewPos} (${bMove.text}).`;
    }
    /* ✅ FIM ATUALIZAÇÃO: Match Predictor logic */
    /* ✅ FIM ADIÇÃO */

    function recomputeAndRender(){
      if (!oldRowsCache || !newRowsCache){
        $("#status").textContent = "Ainda não foi possível carregar os dois arquivos (old e new).";
        return;
      }

      const oldTeams = buildRanking(oldRowsCache);
      const newTeams = buildRanking(newRowsCache);

      const oldPosMap = mapPositions(oldTeams);
      const oldPointsMap = mapPoints(oldTeams);

      const combined = newTeams.map(t => {
        const key = t.team.toLowerCase();
        const oldPos = oldPosMap.get(key);
        const oldPts = oldPointsMap.get(key);

        let posDelta = { text: "NEW", cls: "new" };
        if (oldPos){
          posDelta = computeDelta(oldPos, t.pos);
        }

        let ptsDelta = { text: "NEW", cls: "new" };
        if (oldPts !== undefined){
          ptsDelta = computePointsDiff(oldPts, t.points);
        }

        return {
          team: t.team,
          points: t.points,
          region: t.region,
          tier: t.tier,
          oldPos: oldPos ?? null,
          newPos: t.pos,
          deltaText: oldPos ? posDelta.text : "NEW",
          deltaCls: oldPos ? posDelta.cls : "new",
          pointsDiffText: (oldPts !== undefined) ? ptsDelta.text : "NEW",
          pointsDiffCls: (oldPts !== undefined) ? ptsDelta.cls : "new"
        };
      });

      let up=0, down=0, flat=0, newly=0;
      for (const r of combined){
        if (r.deltaText === "NEW") newly++;
        else if (r.deltaText === "0") flat++;
        else if (r.deltaText.startsWith("+")) up++;
        else if (r.deltaText.startsWith("-")) down++;
      }

      $("#countTeams").textContent = combined.length;
      $("#countUp").textContent = up;
      $("#countDown").textContent = down;
      $("#countFlat").textContent = flat;
      $("#countNew").textContent = newly;
      $("#badges").style.display = "flex";

      lastCombined = combined;
      updateRegionFilterOptions(combined);
      enableFilters(true);
      renderTable(combined);
      $("#btnDownloadCsv").disabled = false;

      /* ✅ ADIÇÃO: initialize/update Region Ranking table */
      updateRegionRankingSelectOptions(combined);
      enableRegionRanking(true);
      recomputeRegionRanking();
      /* ✅ FIM ADIÇÃO */

      /* ✅ ADIÇÃO: Match Predictor data source */
      currentNewTeams = newTeams; // includes points + streak etc.
      updateMatchTeamOptions(currentNewTeams);
      enableMatchPredictor(true);
      renderMatchPredictor();
      /* ✅ FIM ADIÇÃO */

      $("#status").textContent = "Ranking generated.";
    }

    $("#btnCompare").addEventListener("click", () => {
      recomputeAndRender();
    });

    $("#btnUpdateOld").addEventListener("click", async () => {
      try{
        $("#status").textContent = "Atualizando Old…";
        await loadOld(true);
        $("#status").textContent = "Old atualizado. Recalculando…";
        recomputeAndRender();
      }catch(err){
        console.error(err);
        $("#status").textContent = "Erro ao atualizar Old. Verifique se file/old.xlsx existe e está acessível.";
      }
    });

    $("#btnUpdateNew").addEventListener("click", async () => {
      try{
        $("#status").textContent = "Atualizando New…";
        const which = await loadNew(true);
        $("#status").textContent = `New atualizado (${which}). Recalculando…`;
        recomputeAndRender();
      }catch(err){
        console.error(err);
        $("#status").textContent = "Erro ao atualizar New. Verifique se file/new-verion.xlsx (ou file/ranking.xlsx) existe e está acessível.";
      }
    });

    ["filterText","filterRegion","filterTier"].forEach(id => {
      $("#" + id).addEventListener("input", () => { if (lastCombined) renderTable(lastCombined); });
      $("#" + id).addEventListener("change", () => { if (lastCombined) renderTable(lastCombined); });
    });

    $("#btnClearFilters").addEventListener("click", () => {
      $("#filterText").value = "";
      $("#filterRegion").value = "";
      $("#filterTier").value = "";
      if (lastCombined) renderTable(lastCombined);
    });

    $("#btnDownloadCsv").addEventListener("click", () => {
      if (!lastCombined) return;
      const csv = toCsv(lastCombined);
      downloadText("ranking_comparativo.csv", csv, "text/csv;charset=utf-8");
    });

    enableFilters(false);

    /* ✅ ADIÇÃO: region select handler */
    $("#regionRankingSelect").addEventListener("change", () => {
      recomputeRegionRanking();
    });
    /* ✅ FIM ADIÇÃO */

    /* ✅ ADIÇÃO: match predictor handlers */
    enableMatchPredictor(false);
    ["matchTeamA","matchTeamB","matchResult"].forEach(id => {
      $("#" + id).addEventListener("change", () => renderMatchPredictor());
    });
    /* ✅ FIM ADIÇÃO */

    (async () => {
      try{
        $("#status").textContent = "Carregando Old e New automaticamente…";
        await loadOld(false);
        await loadNew(false);
        recomputeAndRender();
      }catch(err){
        console.error(err);
        $("#status").textContent =
          "Não foi possível carregar automaticamente. Verifique se está rodando via servidor e se a pasta /file contém os .xlsx.";
      }
    })();

    // ✅ ALTERADO: Atalho agora é tecla "0" para voltar ao menu (em vez de Delete/Backspace)
    // Não dispara enquanto estiver digitando em inputs/selects/textarea ou contenteditable.
    document.addEventListener("keydown", (e) => {
      if (e.key !== "0" && e.code !== "Numpad0") return;

      const el = document.activeElement;
      const tag = (el && el.tagName) ? el.tagName.toLowerCase() : "";
      const typing =
        tag === "input" ||
        tag === "textarea" ||
        tag === "select" ||
        (el && el.isContentEditable);

      if (typing) return;

      window.location.href = "index.html";
    });
  </script>
</body>
</html>